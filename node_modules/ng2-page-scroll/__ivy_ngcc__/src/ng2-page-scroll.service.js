import { Injectable, Optional, SkipSelf, isDevMode } from '@angular/core';
import { PageScrollConfig } from './ng2-page-scroll-config';
import { PageScrollUtilService as Util } from './ng2-page-scroll-util.service';
import * as ɵngcc0 from '@angular/core';
var PageScrollService = (function () {
    function PageScrollService() {
        var _this = this;
        this.runningInstances = [];
        this.onInterrupted = {
            report: function (event, pageScrollInstance) {
                if (!pageScrollInstance.interruptible) {
                    // Non-interruptible anyway, so do not stop anything
                    return;
                }
                var shouldStop = true;
                if (event.type === 'keyup') {
                    // Only stop if specific keys have been pressed, for all others don't stop anything
                    if (PageScrollConfig._interruptKeys.indexOf(event.keyCode) === -1) {
                        // The pressed key is not in the list of interrupting keys
                        shouldStop = false;
                    }
                }
                else if (event.type === 'mousedown') {
                    // For mousedown events we only stop the scroll animation of the mouse has
                    // been clicked inside the scrolling container
                    if (!pageScrollInstance.scrollingViews.some(function (scrollingView) { return scrollingView.contains(event.target); })) {
                        // Mouse clicked an element which is not inside any of the the scrolling containers
                        shouldStop = false;
                    }
                }
                if (shouldStop) {
                    _this.stopAll(pageScrollInstance.namespace);
                }
            }
        };
        if (PageScrollService.instanceCounter > 0 &&
            (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode()))) {
            console.warn('An instance of PageScrollService already exists, usually ' +
                'including one provider should be enough, so double check.');
        }
        PageScrollService.instanceCounter++;
    }
    PageScrollService.prototype.stopInternal = function (interrupted, pageScrollInstance) {
        var index = this.runningInstances.indexOf(pageScrollInstance);
        if (index >= 0) {
            this.runningInstances.splice(index, 1);
        }
        if (pageScrollInstance.interruptListenersAttached) {
            pageScrollInstance.detachInterruptListeners();
        }
        if (pageScrollInstance.timer) {
            // Clear/Stop the timer
            clearInterval(pageScrollInstance.timer);
            // Clear the reference to this timer
            pageScrollInstance.timer = undefined;
            pageScrollInstance.fireEvent(!interrupted);
            return true;
        }
        return false;
    };
    /**
     * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.
     *
     * This is the core functionality of the whole library.
     *
     * @param pageScrollInstance
     */
    PageScrollService.prototype.start = function (pageScrollInstance) {
        var _this = this;
        // Stop all possibly running scroll animations in the same namespace
        this.stopAll(pageScrollInstance.namespace);
        if (pageScrollInstance.scrollingViews === null || pageScrollInstance.scrollingViews.length === 0) {
            // No scrollingViews specified, thus we can't animate anything
            if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {
                console.warn('No scrollingViews specified, this ng2-page-scroll does not know which DOM elements to scroll');
            }
            return;
        }
        var startScrollPositionFound = false;
        // Reset start scroll position to 0. If any of the scrollingViews has a different one, it will be extracted next
        pageScrollInstance.startScrollPosition = 0;
        // Get the start scroll position from the scrollingViews (e.g. if the user already scrolled down the content)
        pageScrollInstance.scrollingViews.forEach(function (scrollingView) {
            if (Util.isUndefinedOrNull(scrollingView)) {
                return;
            }
            // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its "scrollTop"
            // or "scrollLeft" property that is not undefined and unequal to 0
            var scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);
            if (!startScrollPositionFound && scrollPosition) {
                // We found a scrollingView that does not have scrollTop or scrollLeft 0
                // Return the scroll position value, as this will be our startScrollPosition
                pageScrollInstance.startScrollPosition = scrollPosition;
                startScrollPositionFound = true;
            }
        });
        var pageScrollOffset = pageScrollInstance.getCurrentOffset();
        // Calculate the target position that the scroll animation should go to
        var scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();
        pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset);
        // Calculate the distance we need to go in total
        pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;
        if (isNaN(pageScrollInstance.distanceToScroll)) {
            // We weren't able to find the target position, maybe the element does not exist?
            if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {
                console.log('Scrolling not possible, as we can\'t find the specified target');
            }
            pageScrollInstance.fireEvent(false);
            return;
        }
        // We're at the final destination already
        // OR we need to scroll down but are already at the end
        // OR we need to scroll up but are at the top already
        var allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < PageScrollConfig._minScrollDistance;
        // Check how long we need to scroll if a speed option is given
        // Default executionDuration is the specified duration
        pageScrollInstance.executionDuration = pageScrollInstance.duration;
        // Maybe we need to pay attention to the speed option?
        if (!Util.isUndefinedOrNull(pageScrollInstance.speed) && Util.isUndefinedOrNull(pageScrollInstance.duration)) {
            // Speed option is set and no duration => calculate duration based on speed and scroll distance
            pageScrollInstance.executionDuration = Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.speed * 1000;
        }
        // We should go there directly, as our "animation" would have one big step
        // only anyway and this way we save the interval stuff
        var tooShortInterval = pageScrollInstance.executionDuration <= PageScrollConfig._interval;
        if (allReadyAtDestination || tooShortInterval) {
            if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {
                if (allReadyAtDestination) {
                    console.log('Scrolling not possible, as we can\'t get any closer to the destination');
                }
                else {
                    console.log('Scroll duration shorter that interval length, jumping to target');
                }
            }
            pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);
            pageScrollInstance.fireEvent(true);
            return;
        }
        // Register the interrupt listeners if we want an interruptible scroll animation
        if (pageScrollInstance.interruptible ||
            (Util.isUndefinedOrNull(pageScrollInstance.interruptible) && PageScrollConfig.defaultInterruptible)) {
            pageScrollInstance.attachInterruptListeners(this.onInterrupted);
        }
        // Let's get started, get the start time...
        pageScrollInstance.startTime = new Date().getTime();
        // .. and calculate the end time (when we need to finish at last)
        pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;
        pageScrollInstance.timer = setInterval(function (_pageScrollInstance) {
            // Take the current time
            var currentTime = new Date().getTime();
            // Determine the new scroll position
            var newScrollPosition;
            var stopNow = false;
            if (_pageScrollInstance.endTime <= currentTime) {
                // We're over the time already, so go the targetScrollPosition (aka destination)
                newScrollPosition = _pageScrollInstance.targetScrollPosition;
                stopNow = true;
            }
            else {
                // Calculate the scroll position based on the current time using the easing function
                newScrollPosition = Math.round(_pageScrollInstance.easingLogic.ease(currentTime - _pageScrollInstance.startTime, _pageScrollInstance.startScrollPosition, _pageScrollInstance.distanceToScroll, _pageScrollInstance.executionDuration));
            }
            // Set the new scrollPosition to all scrollingViews elements
            if (!_pageScrollInstance.setScrollPosition(newScrollPosition)) {
                // Setting the new scrollTop/scrollLeft value failed for all ScrollingViews
                // early stop the scroll animation to save resources
                stopNow = true;
            }
            // At the end do the internal stop maintenance and fire the pageScrollFinish event
            // (otherwise the event might arrive at "too early")
            if (stopNow) {
                _this.stopInternal(false, _pageScrollInstance);
            }
        }, PageScrollConfig._interval, pageScrollInstance);
        // Register the instance as running one
        this.runningInstances.push(pageScrollInstance);
    };
    /**
     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.
     *
     * @param namespace
     * @returns {boolean}
     */
    PageScrollService.prototype.stopAll = function (namespace) {
        if (this.runningInstances.length > 0) {
            var stoppedSome = false;
            for (var i = 0; i < this.runningInstances.length; ++i) {
                var pageScrollInstance = this.runningInstances[i];
                if (Util.isUndefinedOrNull(namespace) || namespace.length === 0 ||
                    pageScrollInstance.namespace === namespace) {
                    stoppedSome = true;
                    this.stopInternal(true, pageScrollInstance);
                    // Decrease the counter, as we removed an item from the array we iterate over
                    i--;
                }
            }
            return stoppedSome;
        }
        return false;
    };
    PageScrollService.prototype.stop = function (pageScrollInstance) {
        return this.stopInternal(true, pageScrollInstance);
    };
    PageScrollService.instanceCounter = 0;
    /** @nocollapse */
    PageScrollService.ctorParameters = function () { return []; };
PageScrollService.ɵfac = function PageScrollService_Factory(t) { return new (t || PageScrollService)(); };
PageScrollService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PageScrollService, factory: function (t) { return PageScrollService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PageScrollService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return PageScrollService;
}());
export { PageScrollService };
/* singleton pattern taken from https://github.com/angular/angular/issues/13854 */
export function NG2PAGESCROLL_SERVICE_PROVIDER_FACTORY(parentDispatcher) {
    return parentDispatcher || new PageScrollService();
}
export var NG2PAGESCROLL_SERVICE_PROVIDER = {
    provide: PageScrollService,
    deps: [[new Optional(), new SkipSelf(), PageScrollService]],
    useFactory: NG2PAGESCROLL_SERVICE_PROVIDER_FACTORY
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmcyLXBhZ2Utc2Nyb2xsLnNlcnZpY2UuanMiLCJzb3VyY2VzIjpbIm5nMi1wYWdlLXNjcm9sbC5zZXJ2aWNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MENBdU0wQyxBQUdwQzs7Ozs7OztnREFFNEQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCwgU2tpcFNlbGYsIGlzRGV2TW9kZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUGFnZVNjcm9sbENvbmZpZyB9IGZyb20gJy4vbmcyLXBhZ2Utc2Nyb2xsLWNvbmZpZyc7XG5pbXBvcnQgeyBQYWdlU2Nyb2xsVXRpbFNlcnZpY2UgYXMgVXRpbCB9IGZyb20gJy4vbmcyLXBhZ2Utc2Nyb2xsLXV0aWwuc2VydmljZSc7XG52YXIgUGFnZVNjcm9sbFNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhZ2VTY3JvbGxTZXJ2aWNlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJ1bm5pbmdJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5vbkludGVycnVwdGVkID0ge1xuICAgICAgICAgICAgcmVwb3J0OiBmdW5jdGlvbiAoZXZlbnQsIHBhZ2VTY3JvbGxJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICghcGFnZVNjcm9sbEluc3RhbmNlLmludGVycnVwdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm9uLWludGVycnVwdGlibGUgYW55d2F5LCBzbyBkbyBub3Qgc3RvcCBhbnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzaG91bGRTdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHN0b3AgaWYgc3BlY2lmaWMga2V5cyBoYXZlIGJlZW4gcHJlc3NlZCwgZm9yIGFsbCBvdGhlcnMgZG9uJ3Qgc3RvcCBhbnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoUGFnZVNjcm9sbENvbmZpZy5faW50ZXJydXB0S2V5cy5pbmRleE9mKGV2ZW50LmtleUNvZGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByZXNzZWQga2V5IGlzIG5vdCBpbiB0aGUgbGlzdCBvZiBpbnRlcnJ1cHRpbmcga2V5c1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBtb3VzZWRvd24gZXZlbnRzIHdlIG9ubHkgc3RvcCB0aGUgc2Nyb2xsIGFuaW1hdGlvbiBvZiB0aGUgbW91c2UgaGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZW4gY2xpY2tlZCBpbnNpZGUgdGhlIHNjcm9sbGluZyBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYWdlU2Nyb2xsSW5zdGFuY2Uuc2Nyb2xsaW5nVmlld3Muc29tZShmdW5jdGlvbiAoc2Nyb2xsaW5nVmlldykgeyByZXR1cm4gc2Nyb2xsaW5nVmlldy5jb250YWlucyhldmVudC50YXJnZXQpOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW91c2UgY2xpY2tlZCBhbiBlbGVtZW50IHdoaWNoIGlzIG5vdCBpbnNpZGUgYW55IG9mIHRoZSB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFN0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdG9wQWxsKHBhZ2VTY3JvbGxJbnN0YW5jZS5uYW1lc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFBhZ2VTY3JvbGxTZXJ2aWNlLmluc3RhbmNlQ291bnRlciA+IDAgJiZcbiAgICAgICAgICAgIChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAyIHx8IChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAxICYmIGlzRGV2TW9kZSgpKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gaW5zdGFuY2Ugb2YgUGFnZVNjcm9sbFNlcnZpY2UgYWxyZWFkeSBleGlzdHMsIHVzdWFsbHkgJyArXG4gICAgICAgICAgICAgICAgJ2luY2x1ZGluZyBvbmUgcHJvdmlkZXIgc2hvdWxkIGJlIGVub3VnaCwgc28gZG91YmxlIGNoZWNrLicpO1xuICAgICAgICB9XG4gICAgICAgIFBhZ2VTY3JvbGxTZXJ2aWNlLmluc3RhbmNlQ291bnRlcisrO1xuICAgIH1cbiAgICBQYWdlU2Nyb2xsU2VydmljZS5wcm90b3R5cGUuc3RvcEludGVybmFsID0gZnVuY3Rpb24gKGludGVycnVwdGVkLCBwYWdlU2Nyb2xsSW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5ydW5uaW5nSW5zdGFuY2VzLmluZGV4T2YocGFnZVNjcm9sbEluc3RhbmNlKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMucnVubmluZ0luc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWdlU2Nyb2xsSW5zdGFuY2UuaW50ZXJydXB0TGlzdGVuZXJzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5kZXRhY2hJbnRlcnJ1cHRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFnZVNjcm9sbEluc3RhbmNlLnRpbWVyKSB7XG4gICAgICAgICAgICAvLyBDbGVhci9TdG9wIHRoZSB0aW1lclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChwYWdlU2Nyb2xsSW5zdGFuY2UudGltZXIpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHJlZmVyZW5jZSB0byB0aGlzIHRpbWVyXG4gICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuZmlyZUV2ZW50KCFpbnRlcnJ1cHRlZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBhIHNjcm9sbCBhbmltYXRpb24uIEFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBhbmltYXRpb24gYXJlIHN0b3JlZCBpbiB0aGUgZ2l2ZW4ge0BsaW5rIFBhZ2VTY3JvbGxJbnN0YW5jZX0gb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhpcyBpcyB0aGUgY29yZSBmdW5jdGlvbmFsaXR5IG9mIHRoZSB3aG9sZSBsaWJyYXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhZ2VTY3JvbGxJbnN0YW5jZVxuICAgICAqL1xuICAgIFBhZ2VTY3JvbGxTZXJ2aWNlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChwYWdlU2Nyb2xsSW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gU3RvcCBhbGwgcG9zc2libHkgcnVubmluZyBzY3JvbGwgYW5pbWF0aW9ucyBpbiB0aGUgc2FtZSBuYW1lc3BhY2VcbiAgICAgICAgdGhpcy5zdG9wQWxsKHBhZ2VTY3JvbGxJbnN0YW5jZS5uYW1lc3BhY2UpO1xuICAgICAgICBpZiAocGFnZVNjcm9sbEluc3RhbmNlLnNjcm9sbGluZ1ZpZXdzID09PSBudWxsIHx8IHBhZ2VTY3JvbGxJbnN0YW5jZS5zY3JvbGxpbmdWaWV3cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vIHNjcm9sbGluZ1ZpZXdzIHNwZWNpZmllZCwgdGh1cyB3ZSBjYW4ndCBhbmltYXRlIGFueXRoaW5nXG4gICAgICAgICAgICBpZiAoUGFnZVNjcm9sbENvbmZpZy5fbG9nTGV2ZWwgPj0gMiB8fCAoUGFnZVNjcm9sbENvbmZpZy5fbG9nTGV2ZWwgPj0gMSAmJiBpc0Rldk1vZGUoKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIHNjcm9sbGluZ1ZpZXdzIHNwZWNpZmllZCwgdGhpcyBuZzItcGFnZS1zY3JvbGwgZG9lcyBub3Qga25vdyB3aGljaCBET00gZWxlbWVudHMgdG8gc2Nyb2xsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0U2Nyb2xsUG9zaXRpb25Gb3VuZCA9IGZhbHNlO1xuICAgICAgICAvLyBSZXNldCBzdGFydCBzY3JvbGwgcG9zaXRpb24gdG8gMC4gSWYgYW55IG9mIHRoZSBzY3JvbGxpbmdWaWV3cyBoYXMgYSBkaWZmZXJlbnQgb25lLCBpdCB3aWxsIGJlIGV4dHJhY3RlZCBuZXh0XG4gICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5zdGFydFNjcm9sbFBvc2l0aW9uID0gMDtcbiAgICAgICAgLy8gR2V0IHRoZSBzdGFydCBzY3JvbGwgcG9zaXRpb24gZnJvbSB0aGUgc2Nyb2xsaW5nVmlld3MgKGUuZy4gaWYgdGhlIHVzZXIgYWxyZWFkeSBzY3JvbGxlZCBkb3duIHRoZSBjb250ZW50KVxuICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2Uuc2Nyb2xsaW5nVmlld3MuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsaW5nVmlldykge1xuICAgICAgICAgICAgaWYgKFV0aWwuaXNVbmRlZmluZWRPck51bGwoc2Nyb2xsaW5nVmlldykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0IHZhbHVlIG9mIHRoZSBmaXJzdCBzY3JvbGxpbmdWaWV3IHRoYXQgcmV0dXJucyBhIHZhbHVlIGZvciBpdHMgXCJzY3JvbGxUb3BcIlxuICAgICAgICAgICAgLy8gb3IgXCJzY3JvbGxMZWZ0XCIgcHJvcGVydHkgdGhhdCBpcyBub3QgdW5kZWZpbmVkIGFuZCB1bmVxdWFsIHRvIDBcbiAgICAgICAgICAgIHZhciBzY3JvbGxQb3NpdGlvbiA9IHBhZ2VTY3JvbGxJbnN0YW5jZS5nZXRTY3JvbGxQcm9wZXJ0eVZhbHVlKHNjcm9sbGluZ1ZpZXcpO1xuICAgICAgICAgICAgaWYgKCFzdGFydFNjcm9sbFBvc2l0aW9uRm91bmQgJiYgc2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHNjcm9sbGluZ1ZpZXcgdGhhdCBkb2VzIG5vdCBoYXZlIHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0IDBcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNjcm9sbCBwb3NpdGlvbiB2YWx1ZSwgYXMgdGhpcyB3aWxsIGJlIG91ciBzdGFydFNjcm9sbFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLnN0YXJ0U2Nyb2xsUG9zaXRpb24gPSBzY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBzdGFydFNjcm9sbFBvc2l0aW9uRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhZ2VTY3JvbGxPZmZzZXQgPSBwYWdlU2Nyb2xsSW5zdGFuY2UuZ2V0Q3VycmVudE9mZnNldCgpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHRhcmdldCBwb3NpdGlvbiB0aGF0IHRoZSBzY3JvbGwgYW5pbWF0aW9uIHNob3VsZCBnbyB0b1xuICAgICAgICB2YXIgc2Nyb2xsVGFyZ2V0UG9zaXRpb24gPSBwYWdlU2Nyb2xsSW5zdGFuY2UuZXh0cmFjdFNjcm9sbFRhcmdldFBvc2l0aW9uKCk7XG4gICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS50YXJnZXRTY3JvbGxQb3NpdGlvbiA9IE1hdGgucm91bmQoKHBhZ2VTY3JvbGxJbnN0YW5jZS52ZXJ0aWNhbFNjcm9sbGluZyA/IHNjcm9sbFRhcmdldFBvc2l0aW9uLnRvcCA6IHNjcm9sbFRhcmdldFBvc2l0aW9uLmxlZnQpIC0gcGFnZVNjcm9sbE9mZnNldCk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugd2UgbmVlZCB0byBnbyBpbiB0b3RhbFxuICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuZGlzdGFuY2VUb1Njcm9sbCA9IHBhZ2VTY3JvbGxJbnN0YW5jZS50YXJnZXRTY3JvbGxQb3NpdGlvbiAtIHBhZ2VTY3JvbGxJbnN0YW5jZS5zdGFydFNjcm9sbFBvc2l0aW9uO1xuICAgICAgICBpZiAoaXNOYU4ocGFnZVNjcm9sbEluc3RhbmNlLmRpc3RhbmNlVG9TY3JvbGwpKSB7XG4gICAgICAgICAgICAvLyBXZSB3ZXJlbid0IGFibGUgdG8gZmluZCB0aGUgdGFyZ2V0IHBvc2l0aW9uLCBtYXliZSB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdD9cbiAgICAgICAgICAgIGlmIChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAyIHx8IChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAxICYmIGlzRGV2TW9kZSgpKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTY3JvbGxpbmcgbm90IHBvc3NpYmxlLCBhcyB3ZSBjYW5cXCd0IGZpbmQgdGhlIHNwZWNpZmllZCB0YXJnZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5maXJlRXZlbnQoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlJ3JlIGF0IHRoZSBmaW5hbCBkZXN0aW5hdGlvbiBhbHJlYWR5XG4gICAgICAgIC8vIE9SIHdlIG5lZWQgdG8gc2Nyb2xsIGRvd24gYnV0IGFyZSBhbHJlYWR5IGF0IHRoZSBlbmRcbiAgICAgICAgLy8gT1Igd2UgbmVlZCB0byBzY3JvbGwgdXAgYnV0IGFyZSBhdCB0aGUgdG9wIGFscmVhZHlcbiAgICAgICAgdmFyIGFsbFJlYWR5QXREZXN0aW5hdGlvbiA9IE1hdGguYWJzKHBhZ2VTY3JvbGxJbnN0YW5jZS5kaXN0YW5jZVRvU2Nyb2xsKSA8IFBhZ2VTY3JvbGxDb25maWcuX21pblNjcm9sbERpc3RhbmNlO1xuICAgICAgICAvLyBDaGVjayBob3cgbG9uZyB3ZSBuZWVkIHRvIHNjcm9sbCBpZiBhIHNwZWVkIG9wdGlvbiBpcyBnaXZlblxuICAgICAgICAvLyBEZWZhdWx0IGV4ZWN1dGlvbkR1cmF0aW9uIGlzIHRoZSBzcGVjaWZpZWQgZHVyYXRpb25cbiAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLmV4ZWN1dGlvbkR1cmF0aW9uID0gcGFnZVNjcm9sbEluc3RhbmNlLmR1cmF0aW9uO1xuICAgICAgICAvLyBNYXliZSB3ZSBuZWVkIHRvIHBheSBhdHRlbnRpb24gdG8gdGhlIHNwZWVkIG9wdGlvbj9cbiAgICAgICAgaWYgKCFVdGlsLmlzVW5kZWZpbmVkT3JOdWxsKHBhZ2VTY3JvbGxJbnN0YW5jZS5zcGVlZCkgJiYgVXRpbC5pc1VuZGVmaW5lZE9yTnVsbChwYWdlU2Nyb2xsSW5zdGFuY2UuZHVyYXRpb24pKSB7XG4gICAgICAgICAgICAvLyBTcGVlZCBvcHRpb24gaXMgc2V0IGFuZCBubyBkdXJhdGlvbiA9PiBjYWxjdWxhdGUgZHVyYXRpb24gYmFzZWQgb24gc3BlZWQgYW5kIHNjcm9sbCBkaXN0YW5jZVxuICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLmV4ZWN1dGlvbkR1cmF0aW9uID0gTWF0aC5hYnMocGFnZVNjcm9sbEluc3RhbmNlLmRpc3RhbmNlVG9TY3JvbGwpIC8gcGFnZVNjcm9sbEluc3RhbmNlLnNwZWVkICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBzaG91bGQgZ28gdGhlcmUgZGlyZWN0bHksIGFzIG91ciBcImFuaW1hdGlvblwiIHdvdWxkIGhhdmUgb25lIGJpZyBzdGVwXG4gICAgICAgIC8vIG9ubHkgYW55d2F5IGFuZCB0aGlzIHdheSB3ZSBzYXZlIHRoZSBpbnRlcnZhbCBzdHVmZlxuICAgICAgICB2YXIgdG9vU2hvcnRJbnRlcnZhbCA9IHBhZ2VTY3JvbGxJbnN0YW5jZS5leGVjdXRpb25EdXJhdGlvbiA8PSBQYWdlU2Nyb2xsQ29uZmlnLl9pbnRlcnZhbDtcbiAgICAgICAgaWYgKGFsbFJlYWR5QXREZXN0aW5hdGlvbiB8fCB0b29TaG9ydEludGVydmFsKSB7XG4gICAgICAgICAgICBpZiAoUGFnZVNjcm9sbENvbmZpZy5fbG9nTGV2ZWwgPj0gMiB8fCAoUGFnZVNjcm9sbENvbmZpZy5fbG9nTGV2ZWwgPj0gMSAmJiBpc0Rldk1vZGUoKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxsUmVhZHlBdERlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTY3JvbGxpbmcgbm90IHBvc3NpYmxlLCBhcyB3ZSBjYW5cXCd0IGdldCBhbnkgY2xvc2VyIHRvIHRoZSBkZXN0aW5hdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1Njcm9sbCBkdXJhdGlvbiBzaG9ydGVyIHRoYXQgaW50ZXJ2YWwgbGVuZ3RoLCBqdW1waW5nIHRvIHRhcmdldCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5zZXRTY3JvbGxQb3NpdGlvbihwYWdlU2Nyb2xsSW5zdGFuY2UudGFyZ2V0U2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLmZpcmVFdmVudCh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWdpc3RlciB0aGUgaW50ZXJydXB0IGxpc3RlbmVycyBpZiB3ZSB3YW50IGFuIGludGVycnVwdGlibGUgc2Nyb2xsIGFuaW1hdGlvblxuICAgICAgICBpZiAocGFnZVNjcm9sbEluc3RhbmNlLmludGVycnVwdGlibGUgfHxcbiAgICAgICAgICAgIChVdGlsLmlzVW5kZWZpbmVkT3JOdWxsKHBhZ2VTY3JvbGxJbnN0YW5jZS5pbnRlcnJ1cHRpYmxlKSAmJiBQYWdlU2Nyb2xsQ29uZmlnLmRlZmF1bHRJbnRlcnJ1cHRpYmxlKSkge1xuICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLmF0dGFjaEludGVycnVwdExpc3RlbmVycyh0aGlzLm9uSW50ZXJydXB0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExldCdzIGdldCBzdGFydGVkLCBnZXQgdGhlIHN0YXJ0IHRpbWUuLi5cbiAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAvLyAuLiBhbmQgY2FsY3VsYXRlIHRoZSBlbmQgdGltZSAod2hlbiB3ZSBuZWVkIHRvIGZpbmlzaCBhdCBsYXN0KVxuICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuZW5kVGltZSA9IHBhZ2VTY3JvbGxJbnN0YW5jZS5zdGFydFRpbWUgKyBwYWdlU2Nyb2xsSW5zdGFuY2UuZXhlY3V0aW9uRHVyYXRpb247XG4gICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS50aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uIChfcGFnZVNjcm9sbEluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBUYWtlIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBuZXcgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgICAgICB2YXIgbmV3U2Nyb2xsUG9zaXRpb247XG4gICAgICAgICAgICB2YXIgc3RvcE5vdyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKF9wYWdlU2Nyb2xsSW5zdGFuY2UuZW5kVGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIG92ZXIgdGhlIHRpbWUgYWxyZWFkeSwgc28gZ28gdGhlIHRhcmdldFNjcm9sbFBvc2l0aW9uIChha2EgZGVzdGluYXRpb24pXG4gICAgICAgICAgICAgICAgbmV3U2Nyb2xsUG9zaXRpb24gPSBfcGFnZVNjcm9sbEluc3RhbmNlLnRhcmdldFNjcm9sbFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHN0b3BOb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzY3JvbGwgcG9zaXRpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgdGltZSB1c2luZyB0aGUgZWFzaW5nIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgbmV3U2Nyb2xsUG9zaXRpb24gPSBNYXRoLnJvdW5kKF9wYWdlU2Nyb2xsSW5zdGFuY2UuZWFzaW5nTG9naWMuZWFzZShjdXJyZW50VGltZSAtIF9wYWdlU2Nyb2xsSW5zdGFuY2Uuc3RhcnRUaW1lLCBfcGFnZVNjcm9sbEluc3RhbmNlLnN0YXJ0U2Nyb2xsUG9zaXRpb24sIF9wYWdlU2Nyb2xsSW5zdGFuY2UuZGlzdGFuY2VUb1Njcm9sbCwgX3BhZ2VTY3JvbGxJbnN0YW5jZS5leGVjdXRpb25EdXJhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXcgc2Nyb2xsUG9zaXRpb24gdG8gYWxsIHNjcm9sbGluZ1ZpZXdzIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIV9wYWdlU2Nyb2xsSW5zdGFuY2Uuc2V0U2Nyb2xsUG9zaXRpb24obmV3U2Nyb2xsUG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0dGluZyB0aGUgbmV3IHNjcm9sbFRvcC9zY3JvbGxMZWZ0IHZhbHVlIGZhaWxlZCBmb3IgYWxsIFNjcm9sbGluZ1ZpZXdzXG4gICAgICAgICAgICAgICAgLy8gZWFybHkgc3RvcCB0aGUgc2Nyb2xsIGFuaW1hdGlvbiB0byBzYXZlIHJlc291cmNlc1xuICAgICAgICAgICAgICAgIHN0b3BOb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXQgdGhlIGVuZCBkbyB0aGUgaW50ZXJuYWwgc3RvcCBtYWludGVuYW5jZSBhbmQgZmlyZSB0aGUgcGFnZVNjcm9sbEZpbmlzaCBldmVudFxuICAgICAgICAgICAgLy8gKG90aGVyd2lzZSB0aGUgZXZlbnQgbWlnaHQgYXJyaXZlIGF0IFwidG9vIGVhcmx5XCIpXG4gICAgICAgICAgICBpZiAoc3RvcE5vdykge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0b3BJbnRlcm5hbChmYWxzZSwgX3BhZ2VTY3JvbGxJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFBhZ2VTY3JvbGxDb25maWcuX2ludGVydmFsLCBwYWdlU2Nyb2xsSW5zdGFuY2UpO1xuICAgICAgICAvLyBSZWdpc3RlciB0aGUgaW5zdGFuY2UgYXMgcnVubmluZyBvbmVcbiAgICAgICAgdGhpcy5ydW5uaW5nSW5zdGFuY2VzLnB1c2gocGFnZVNjcm9sbEluc3RhbmNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3AgYWxsIHJ1bm5pbmcgc2Nyb2xsIGFuaW1hdGlvbnMuIE9wdGlvbmFsbHkgbGltaXQgdG8gc3RvcCBvbmx5IHRoZSBvbmVzIG9mIHNwZWNpZmljIG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBQYWdlU2Nyb2xsU2VydmljZS5wcm90b3R5cGUuc3RvcEFsbCA9IGZ1bmN0aW9uIChuYW1lc3BhY2UpIHtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZ0luc3RhbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgc3RvcHBlZFNvbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nSW5zdGFuY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VTY3JvbGxJbnN0YW5jZSA9IHRoaXMucnVubmluZ0luc3RhbmNlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbC5pc1VuZGVmaW5lZE9yTnVsbChuYW1lc3BhY2UpIHx8IG5hbWVzcGFjZS5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRTb21lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wSW50ZXJuYWwodHJ1ZSwgcGFnZVNjcm9sbEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGNvdW50ZXIsIGFzIHdlIHJlbW92ZWQgYW4gaXRlbSBmcm9tIHRoZSBhcnJheSB3ZSBpdGVyYXRlIG92ZXJcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdG9wcGVkU29tZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBQYWdlU2Nyb2xsU2VydmljZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChwYWdlU2Nyb2xsSW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcEludGVybmFsKHRydWUsIHBhZ2VTY3JvbGxJbnN0YW5jZSk7XG4gICAgfTtcbiAgICBQYWdlU2Nyb2xsU2VydmljZS5pbnN0YW5jZUNvdW50ZXIgPSAwO1xuICAgIFBhZ2VTY3JvbGxTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgUGFnZVNjcm9sbFNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gUGFnZVNjcm9sbFNlcnZpY2U7XG59KCkpO1xuZXhwb3J0IHsgUGFnZVNjcm9sbFNlcnZpY2UgfTtcbi8qIHNpbmdsZXRvbiBwYXR0ZXJuIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTM4NTQgKi9cbmV4cG9ydCBmdW5jdGlvbiBORzJQQUdFU0NST0xMX1NFUlZJQ0VfUFJPVklERVJfRkFDVE9SWShwYXJlbnREaXNwYXRjaGVyKSB7XG4gICAgcmV0dXJuIHBhcmVudERpc3BhdGNoZXIgfHwgbmV3IFBhZ2VTY3JvbGxTZXJ2aWNlKCk7XG59XG5leHBvcnQgdmFyIE5HMlBBR0VTQ1JPTExfU0VSVklDRV9QUk9WSURFUiA9IHtcbiAgICBwcm92aWRlOiBQYWdlU2Nyb2xsU2VydmljZSxcbiAgICBkZXBzOiBbW25ldyBPcHRpb25hbCgpLCBuZXcgU2tpcFNlbGYoKSwgUGFnZVNjcm9sbFNlcnZpY2VdXSxcbiAgICB1c2VGYWN0b3J5OiBORzJQQUdFU0NST0xMX1NFUlZJQ0VfUFJPVklERVJfRkFDVE9SWVxufTtcbiJdfQ==