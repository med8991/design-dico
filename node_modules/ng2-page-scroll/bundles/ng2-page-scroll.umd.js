(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/router'),require('@angular/common'),exports, require('@angular/core'), require('@angular/router'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define(['@angular/core','@angular/router','@angular/common','exports', '@angular/core', '@angular/router', '@angular/common'], factory) :
	(factory(global.ng.core,global.ng.router,global.ng.common,(global.ng2 = global.ng2 || {}, global.ng2.page = global.ng2.page || {}, global.ng2.page.scroll = {}),global.ng.core,global.ng.router,global.ng.common));
}(this, (function (ɵngcc0,ɵngcc1,ɵngcc2,exports,core,router,common) { 'use strict';

var EasingLogic = (function () {
    function EasingLogic() {
    }
    return EasingLogic;
}());
var PageScrollConfig = (function () {
    function PageScrollConfig() {
    }
    Object.defineProperty(PageScrollConfig, "defaultEasingLogic", {
        // Getter and setter to avoid auto completion to suggest calling the method
        get: function () {
            return PageScrollConfig._easingLogic;
        },
        set: function (easingLogic) {
            PageScrollConfig._easingLogic = easingLogic;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * The number of milliseconds to wait till updating the scroll position again.
     * Small amounts may produce smoother animations but require more processing power.
     * @type {number}
     * @private
     */
    PageScrollConfig._interval = 10;
    /**
     * The amount of pixels that need to be between the current scrollTop/scrollLeft position
     * and the target position the cause a scroll animation. In case distance is below
     * this threshold, an immediate jump will be performed.
     * Due to dpi or rounding irregularities in browsers floating point numbers for scrollTop/scrollLeft values
     * are possible, making a === comparison of current scrollTop or scrollLeft and target scrollPosition error-prone.
     * @type {number}
     * @private
     */
    PageScrollConfig._minScrollDistance = 2;
    /**
     * Name of the default namespace.
     * @type {string}
     * @private
     */
    PageScrollConfig._defaultNamespace = 'default';
    /**
     * Whether by default the scrolling should happen in vertical direction (by manipulating the scrollTop property)
     * (= true; default) or in horizontal direction (by manipulating the scrollLeft property) (= false
     * @type {boolean}
     */
    PageScrollConfig.defaultIsVerticalScrolling = true;
    /**
     * How many console logs should be emitted. Also influenced by angular mode (dev or prod mode)
     * 0: No logs, neither in dev nor in prod mode
     * 1: Animation errors in dev mode, no logs in prod mode
     * 2: Animation errors in dev and prod mode
     * 5: Animation errors in dev and all scroll position values that get set; animation errors in prod mode
     * @type {boolean}
     * @private
     */
    PageScrollConfig._logLevel = 2;
    /**
     * The duration how long a scrollTo animation should last by default.
     * May be overridden using the page-scroll-duration attribute on a single ng2PageScroll instance.
     * @type {number}
     */
    PageScrollConfig.defaultDuration = 1250;
    /**
     * The distance in pixels above scroll target where the animation should stop. Setting a positive number results in
     * the scroll target being more in the middle of the screen, negative numbers will produce scrolling "too far"
     * @type {number}
     */
    PageScrollConfig.defaultScrollOffset = 0;
    /**
     * Whether by default for inline scroll animations the advanced offset calculation should take place (true) or
     * not (false). Default is false.
     * The advanced offset calculation will traverse the DOM tree upwards, starting at the scrollTarget, until it finds
     * the scrollingView container element. Along the way the offset positions of the relative positioned
     * (position: relative) elements will be taken into account for calculating the target elements position.
     * @type {boolean}
     */
    PageScrollConfig.defaultAdvancedInlineOffsetCalculation = false;
    /**
     * The events that are listened to on the body to decide whether a scroll animation has been interfered/interrupted by the user
     * @type {string[]}
     * @private
     */
    PageScrollConfig._interruptEvents = ['mousedown', 'wheel', 'DOMMouseScroll', 'mousewheel', 'keyup', 'touchmove'];
    /**
     * The keys that are considered to interrupt a scroll animation (mainly the arrow keys). All other key presses will not stop the
     * scroll animation.
     * @type {number[]}
     * @private
     */
    PageScrollConfig._interruptKeys = [33, 34, 35, 36, 38, 40];
    /**
     * Whether a scroll animation should be interruptible by user interaction (true) or not (false). If the user performs an
     * interrupting event while a scroll animation takes place, the scroll animation stops.
     * @type {boolean}
     */
    PageScrollConfig.defaultInterruptible = true;
    PageScrollConfig._easingLogic = {
        ease: function (t, b, c, d) {
            // Linear easing
            return c * t / d + b;
        }
    };
    return PageScrollConfig;
}());

var PageScrollUtilService = (function () {
    function PageScrollUtilService() {
    }
    /**
     * Util method to check whether a given variable is either undefined or null
     * @param variable
     * @returns {boolean} true the variable is undefined or null
     */
    PageScrollUtilService.isUndefinedOrNull = function (variable) {
        return (typeof variable === 'undefined') || variable === undefined || variable === null;
    };
    PageScrollUtilService.extractElementPosition = function (document, scrollTargetElement) {
        var body = document.body;
        var docEl = document.documentElement;
        var windowPageYOffset = document.defaultView && document.defaultView.pageYOffset || undefined;
        var windowPageXOffset = document.defaultView && document.defaultView.pageXOffset || undefined;
        var scrollTop = windowPageYOffset || docEl.scrollTop || body.scrollTop;
        var scrollLeft = windowPageXOffset || docEl.scrollLeft || body.scrollLeft;
        var clientTop = docEl.clientTop || body.clientTop || 0;
        var clientLeft = docEl.clientLeft || body.clientLeft || 0;
        if (PageScrollUtilService.isUndefinedOrNull(scrollTargetElement)) {
            // No element found, so return the current position to not cause any change in scroll position
            return { top: scrollTop, left: scrollLeft };
        }
        var box = scrollTargetElement.getBoundingClientRect();
        var top = box.top + scrollTop - clientTop;
        var left = box.left + scrollLeft - clientLeft;
        return { top: Math.round(top), left: Math.round(left) };
    };
    return PageScrollUtilService;
}());

var PageScrollService = (function () {
    function PageScrollService() {
        var _this = this;
        this.runningInstances = [];
        this.onInterrupted = {
            report: function (event, pageScrollInstance) {
                if (!pageScrollInstance.interruptible) {
                    // Non-interruptible anyway, so do not stop anything
                    return;
                }
                var shouldStop = true;
                if (event.type === 'keyup') {
                    // Only stop if specific keys have been pressed, for all others don't stop anything
                    if (PageScrollConfig._interruptKeys.indexOf(event.keyCode) === -1) {
                        // The pressed key is not in the list of interrupting keys
                        shouldStop = false;
                    }
                }
                else if (event.type === 'mousedown') {
                    // For mousedown events we only stop the scroll animation of the mouse has
                    // been clicked inside the scrolling container
                    if (!pageScrollInstance.scrollingViews.some(function (scrollingView) { return scrollingView.contains(event.target); })) {
                        // Mouse clicked an element which is not inside any of the the scrolling containers
                        shouldStop = false;
                    }
                }
                if (shouldStop) {
                    _this.stopAll(pageScrollInstance.namespace);
                }
            }
        };
        if (PageScrollService.instanceCounter > 0 &&
            (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && core.isDevMode()))) {
            console.warn('An instance of PageScrollService already exists, usually ' +
                'including one provider should be enough, so double check.');
        }
        PageScrollService.instanceCounter++;
    }
    PageScrollService.prototype.stopInternal = function (interrupted, pageScrollInstance) {
        var index = this.runningInstances.indexOf(pageScrollInstance);
        if (index >= 0) {
            this.runningInstances.splice(index, 1);
        }
        if (pageScrollInstance.interruptListenersAttached) {
            pageScrollInstance.detachInterruptListeners();
        }
        if (pageScrollInstance.timer) {
            // Clear/Stop the timer
            clearInterval(pageScrollInstance.timer);
            // Clear the reference to this timer
            pageScrollInstance.timer = undefined;
            pageScrollInstance.fireEvent(!interrupted);
            return true;
        }
        return false;
    };
    /**
     * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.
     *
     * This is the core functionality of the whole library.
     *
     * @param pageScrollInstance
     */
    PageScrollService.prototype.start = function (pageScrollInstance) {
        var _this = this;
        // Stop all possibly running scroll animations in the same namespace
        this.stopAll(pageScrollInstance.namespace);
        if (pageScrollInstance.scrollingViews === null || pageScrollInstance.scrollingViews.length === 0) {
            // No scrollingViews specified, thus we can't animate anything
            if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && core.isDevMode())) {
                console.warn('No scrollingViews specified, this ng2-page-scroll does not know which DOM elements to scroll');
            }
            return;
        }
        var startScrollPositionFound = false;
        // Reset start scroll position to 0. If any of the scrollingViews has a different one, it will be extracted next
        pageScrollInstance.startScrollPosition = 0;
        // Get the start scroll position from the scrollingViews (e.g. if the user already scrolled down the content)
        pageScrollInstance.scrollingViews.forEach(function (scrollingView) {
            if (PageScrollUtilService.isUndefinedOrNull(scrollingView)) {
                return;
            }
            // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its "scrollTop"
            // or "scrollLeft" property that is not undefined and unequal to 0
            var scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);
            if (!startScrollPositionFound && scrollPosition) {
                // We found a scrollingView that does not have scrollTop or scrollLeft 0
                // Return the scroll position value, as this will be our startScrollPosition
                pageScrollInstance.startScrollPosition = scrollPosition;
                startScrollPositionFound = true;
            }
        });
        var pageScrollOffset = pageScrollInstance.getCurrentOffset();
        // Calculate the target position that the scroll animation should go to
        var scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();
        pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset);
        // Calculate the distance we need to go in total
        pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;
        if (isNaN(pageScrollInstance.distanceToScroll)) {
            // We weren't able to find the target position, maybe the element does not exist?
            if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && core.isDevMode())) {
                console.log('Scrolling not possible, as we can\'t find the specified target');
            }
            pageScrollInstance.fireEvent(false);
            return;
        }
        // We're at the final destination already
        // OR we need to scroll down but are already at the end
        // OR we need to scroll up but are at the top already
        var allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < PageScrollConfig._minScrollDistance;
        // Check how long we need to scroll if a speed option is given
        // Default executionDuration is the specified duration
        pageScrollInstance.executionDuration = pageScrollInstance.duration;
        // Maybe we need to pay attention to the speed option?
        if (!PageScrollUtilService.isUndefinedOrNull(pageScrollInstance.speed) && PageScrollUtilService.isUndefinedOrNull(pageScrollInstance.duration)) {
            // Speed option is set and no duration => calculate duration based on speed and scroll distance
            pageScrollInstance.executionDuration = Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.speed * 1000;
        }
        // We should go there directly, as our "animation" would have one big step
        // only anyway and this way we save the interval stuff
        var tooShortInterval = pageScrollInstance.executionDuration <= PageScrollConfig._interval;
        if (allReadyAtDestination || tooShortInterval) {
            if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && core.isDevMode())) {
                if (allReadyAtDestination) {
                    console.log('Scrolling not possible, as we can\'t get any closer to the destination');
                }
                else {
                    console.log('Scroll duration shorter that interval length, jumping to target');
                }
            }
            pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);
            pageScrollInstance.fireEvent(true);
            return;
        }
        // Register the interrupt listeners if we want an interruptible scroll animation
        if (pageScrollInstance.interruptible ||
            (PageScrollUtilService.isUndefinedOrNull(pageScrollInstance.interruptible) && PageScrollConfig.defaultInterruptible)) {
            pageScrollInstance.attachInterruptListeners(this.onInterrupted);
        }
        // Let's get started, get the start time...
        pageScrollInstance.startTime = new Date().getTime();
        // .. and calculate the end time (when we need to finish at last)
        pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;
        pageScrollInstance.timer = setInterval(function (_pageScrollInstance) {
            // Take the current time
            var currentTime = new Date().getTime();
            // Determine the new scroll position
            var newScrollPosition;
            var stopNow = false;
            if (_pageScrollInstance.endTime <= currentTime) {
                // We're over the time already, so go the targetScrollPosition (aka destination)
                newScrollPosition = _pageScrollInstance.targetScrollPosition;
                stopNow = true;
            }
            else {
                // Calculate the scroll position based on the current time using the easing function
                newScrollPosition = Math.round(_pageScrollInstance.easingLogic.ease(currentTime - _pageScrollInstance.startTime, _pageScrollInstance.startScrollPosition, _pageScrollInstance.distanceToScroll, _pageScrollInstance.executionDuration));
            }
            // Set the new scrollPosition to all scrollingViews elements
            if (!_pageScrollInstance.setScrollPosition(newScrollPosition)) {
                // Setting the new scrollTop/scrollLeft value failed for all ScrollingViews
                // early stop the scroll animation to save resources
                stopNow = true;
            }
            // At the end do the internal stop maintenance and fire the pageScrollFinish event
            // (otherwise the event might arrive at "too early")
            if (stopNow) {
                _this.stopInternal(false, _pageScrollInstance);
            }
        }, PageScrollConfig._interval, pageScrollInstance);
        // Register the instance as running one
        this.runningInstances.push(pageScrollInstance);
    };
    /**
     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.
     *
     * @param namespace
     * @returns {boolean}
     */
    PageScrollService.prototype.stopAll = function (namespace) {
        if (this.runningInstances.length > 0) {
            var stoppedSome = false;
            for (var i = 0; i < this.runningInstances.length; ++i) {
                var pageScrollInstance = this.runningInstances[i];
                if (PageScrollUtilService.isUndefinedOrNull(namespace) || namespace.length === 0 ||
                    pageScrollInstance.namespace === namespace) {
                    stoppedSome = true;
                    this.stopInternal(true, pageScrollInstance);
                    // Decrease the counter, as we removed an item from the array we iterate over
                    i--;
                }
            }
            return stoppedSome;
        }
        return false;
    };
    PageScrollService.prototype.stop = function (pageScrollInstance) {
        return this.stopInternal(true, pageScrollInstance);
    };
    PageScrollService.instanceCounter = 0;
    /** @nocollapse */
    PageScrollService.ctorParameters = function () { return []; };
PageScrollService.ɵfac = function PageScrollService_Factory(t) { return new (t || PageScrollService)(); };
PageScrollService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PageScrollService, factory: function (t) { return PageScrollService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PageScrollService, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
    return PageScrollService;
}());
/* singleton pattern taken from https://github.com/angular/angular/issues/13854 */
function NG2PAGESCROLL_SERVICE_PROVIDER_FACTORY(parentDispatcher) {
    return parentDispatcher || new PageScrollService();
}
var NG2PAGESCROLL_SERVICE_PROVIDER = {
    provide: PageScrollService,
    deps: [[new core.Optional(), new core.SkipSelf(), PageScrollService]],
    useFactory: NG2PAGESCROLL_SERVICE_PROVIDER_FACTORY
};

/**
 * Represents a scrolling action
 */
var PageScrollInstance = (function () {
    /**
     * Private constructor, requires the properties assumed to be the bare minimum.
     * Use the factory methods to create instances:
     *      {@link PageScrollInstance#simpleInstance}
     *      {@link PageScrollInstance#newInstance}
     * @param namespace
     * @param document
     */
    function PageScrollInstance(namespace, document) {
        /**
         * These properties will be set during instance construction and default to their defaults from PageScrollConfig
         */
        /* A namespace to "group" scroll animations together and stopping some does not stop others */
        this._namespace = PageScrollConfig._defaultNamespace;
        /* Whether we scroll vertically (true) or horizontally (false) */
        this._verticalScrolling = PageScrollConfig.defaultIsVerticalScrolling;
        /* Offset in px that the animation should stop above that target element */
        this._offset = PageScrollConfig.defaultScrollOffset;
        /* Duration in milliseconds the scroll animation should last */
        this._duration = PageScrollConfig.defaultDuration;
        /* Easing function to manipulate the scrollTop/scrollLeft value over time */
        this._easingLogic = PageScrollConfig.defaultEasingLogic;
        /* Boolean whether the scroll animation should stop on user interruption or not */
        this._interruptible = PageScrollConfig.defaultInterruptible;
        /* Whether the advanded offset calculation for inline scrolling should be used */
        this._advancedInlineOffsetCalculation = PageScrollConfig.defaultAdvancedInlineOffsetCalculation;
        /* Event emitter to notify the world about the scrolling */
        this._pageScrollFinish = new core.EventEmitter();
        /**
         * These properties will be set/manipulated if the scroll animation starts
         */
        /* The initial value of the scrollTop or scrollLeft position when the animation starts */
        this._startScrollPosition = 0;
        /* Whether an interrupt listener is attached to the body or not */
        this._interruptListenersAttached = false;
        /* References to the timer instance that is used to perform the scroll animation to be
         able to clear it on animation end*/
        this._timer = null;
        this._namespace = namespace;
        this.document = document;
    }
    /*
     * Factory methods for instance creation
     */
    PageScrollInstance.simpleInstance = function (document, scrollTarget, namespace) {
        return PageScrollInstance.newInstance({
            document: document,
            scrollTarget: scrollTarget,
            namespace: namespace
        });
    };
    PageScrollInstance.newInstance = function (options) {
        if (PageScrollUtilService.isUndefinedOrNull(options.namespace) || options.namespace.length <= 0) {
            options.namespace = PageScrollConfig._defaultNamespace;
        }
        var pageScrollInstance = new PageScrollInstance(options.namespace, document);
        if (PageScrollUtilService.isUndefinedOrNull(options.scrollingViews) || options.scrollingViews.length === 0) {
            pageScrollInstance._isInlineScrolling = false;
            pageScrollInstance._scrollingViews = [document.documentElement, document.body, document.body.parentNode];
        }
        else {
            pageScrollInstance._isInlineScrolling = true;
            pageScrollInstance._scrollingViews = options.scrollingViews;
        }
        pageScrollInstance._scrollTarget = options.scrollTarget;
        if (!PageScrollUtilService.isUndefinedOrNull(options.verticalScrolling)) {
            pageScrollInstance._verticalScrolling = options.verticalScrolling;
        }
        if (!PageScrollUtilService.isUndefinedOrNull(options.pageScrollOffset)) {
            pageScrollInstance._offset = options.pageScrollOffset;
        }
        if (!PageScrollUtilService.isUndefinedOrNull(options.pageScrollEasingLogic)) {
            pageScrollInstance._easingLogic = options.pageScrollEasingLogic;
        }
        if (PageScrollUtilService.isUndefinedOrNull(options.pageScrollDuration) && !PageScrollUtilService.isUndefinedOrNull(options.pageScrollSpeed)) {
            // No duration specified in the options, only in this case we use the speed option when present
            pageScrollInstance._speed = options.pageScrollSpeed;
            pageScrollInstance._duration = undefined;
        }
        else if (!PageScrollUtilService.isUndefinedOrNull(options.pageScrollDuration)) {
            pageScrollInstance._duration = options.pageScrollDuration;
        }
        if (!PageScrollUtilService.isUndefinedOrNull(options.pageScrollFinishListener)) {
            pageScrollInstance._pageScrollFinish = options.pageScrollFinishListener;
        }
        pageScrollInstance._interruptible = options.pageScrollInterruptible ||
            (PageScrollUtilService.isUndefinedOrNull(options.pageScrollInterruptible) && PageScrollConfig.defaultInterruptible);
        pageScrollInstance._advancedInlineOffsetCalculation = options.advancedInlineOffsetCalculation ||
            (PageScrollUtilService.isUndefinedOrNull(options.advancedInlineOffsetCalculation) &&
                PageScrollConfig.defaultAdvancedInlineOffsetCalculation);
        return pageScrollInstance;
    };
    PageScrollInstance.prototype.getScrollPropertyValue = function (scrollingView) {
        if (!this.verticalScrolling) {
            return scrollingView.scrollLeft;
        }
        return scrollingView.scrollTop;
    };
    /**
     * Extract the exact location of the scrollTarget element.
     *
     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be
     * a string like "#heading2", then this method returns the corresponding DOM element for that id.
     *
     * @returns {HTMLElement}
     */
    PageScrollInstance.prototype.extractScrollTargetPosition = function () {
        var scrollTargetElement;
        if (typeof this._scrollTarget === 'string') {
            var targetSelector = this._scrollTarget;
            if (targetSelector.match(/^#[^\s]+$/g) !== null) {
                // It's an id selector and a valid id, as it does not contain any white space characters
                scrollTargetElement = this.document.getElementById(targetSelector.substr(1));
            }
            else {
                scrollTargetElement = this.document.querySelector(targetSelector);
            }
        }
        else {
            scrollTargetElement = this._scrollTarget;
        }
        if (scrollTargetElement === null || scrollTargetElement === undefined) {
            // Scroll target not found
            return { top: NaN, left: NaN };
        }
        if (this._isInlineScrolling) {
            var position = { top: scrollTargetElement.offsetTop, left: scrollTargetElement.offsetLeft };
            if (this._advancedInlineOffsetCalculation && this.scrollingViews.length === 1) {
                var accumulatedParentsPos = { top: 0, left: 0 };
                // not named window to make sure we're not getting the global window variable by accident
                var theWindow = scrollTargetElement.ownerDocument.defaultView;
                var parentFound = false;
                // Start parent is the immediate parent
                var parent_1 = scrollTargetElement.parentElement;
                // Iterate upwards all parents
                while (!parentFound && !PageScrollUtilService.isUndefinedOrNull(parent_1)) {
                    if (theWindow.getComputedStyle(parent_1).getPropertyValue('position') === 'relative') {
                        accumulatedParentsPos.top += parent_1.offsetTop;
                        accumulatedParentsPos.left += parent_1.offsetLeft;
                    }
                    // Next iteration
                    parent_1 = parent_1.parentElement;
                    parentFound = parent_1 === this.scrollingViews[0];
                }
                if (parentFound) {
                    // Only use the results if we found the parent, otherwise we accumulated too much anyway
                    position.top += accumulatedParentsPos.top;
                    position.left += accumulatedParentsPos.left;
                }
                else {
                    if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && core.isDevMode())) {
                        console.warn('Unable to find nested scrolling targets parent!');
                    }
                }
            }
            return position;
        }
        return PageScrollUtilService.extractElementPosition(this.document, scrollTargetElement);
    };
    /**
     * Get the top offset of the scroll animation.
     * This automatically takes the offset location of the scrolling container/scrolling view
     * into account (for nested/inline scrolling).
     *
     * @returns {number}
     */
    PageScrollInstance.prototype.getCurrentOffset = function () {
        return this._offset;
    };
    /**
     * Sets the "scrollTop" or "scrollLeft" property for all scrollingViews to the provided value
     * @param position
     * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.
     *          false if it failed for all ScrollingViews, meaning that we should stop the animation
     *          (probably because we're at the end of the scrolling region)
     */
    PageScrollInstance.prototype.setScrollPosition = function (position) {
        var _this = this;
        if (PageScrollConfig._logLevel >= 5 && core.isDevMode()) {
            console.warn('Scroll Position: ' + position);
        }
        // Set the new scrollTop/scrollLeft to all scrollingViews elements
        return this.scrollingViews.reduce(function (oneAlreadyWorked, scrollingView) {
            var startScrollPropertyValue = _this.getScrollPropertyValue(scrollingView);
            if (scrollingView && !PageScrollUtilService.isUndefinedOrNull(startScrollPropertyValue)) {
                var scrollDistance = Math.abs(startScrollPropertyValue - position);
                // The movement we need to perform is less than 2px
                // This we consider a small movement which some browser may not perform when
                // changing the scrollTop/scrollLeft property
                // Thus in this cases we do not stop the scroll animation, although setting the
                // scrollTop/scrollLeft value "fails"
                var isSmallMovement = scrollDistance < PageScrollConfig._minScrollDistance;
                if (!_this.verticalScrolling) {
                    scrollingView.scrollLeft = position;
                }
                else {
                    scrollingView.scrollTop = position;
                }
                // Return true of setting the new scrollTop/scrollLeft value worked
                // We consider that it worked if the new scrollTop/scrollLeft value is closer to the
                // desired scrollTop/scrollLeft than before (it might not be exactly the value we
                // set due to dpi or rounding irregularities)
                if (isSmallMovement || scrollDistance > Math.abs(_this.getScrollPropertyValue(scrollingView) - position)) {
                    return true;
                }
            }
            return oneAlreadyWorked;
        }, false);
    };
    /**
     * Trigger firing a animation finish event
     * @param value Whether the animation finished at the target (true) or got interrupted (false)
     */
    PageScrollInstance.prototype.fireEvent = function (value) {
        if (this._pageScrollFinish) {
            this._pageScrollFinish.emit(value);
        }
    };
    /**
     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter
     * will be called if any of the attached events is fired.
     *
     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.
     *
     * @param interruptReporter
     */
    PageScrollInstance.prototype.attachInterruptListeners = function (interruptReporter) {
        var _this = this;
        if (this._interruptListenersAttached) {
            // Detach possibly existing listeners first
            this.detachInterruptListeners();
        }
        this._interruptListener = function (event) {
            interruptReporter.report(event, _this);
        };
        PageScrollConfig._interruptEvents.forEach(function (event) { return _this.document.body.addEventListener(event, _this._interruptListener); });
        this._interruptListenersAttached = true;
    };
    /**
     * Remove event listeners from the body and stop listening for events that might be treated as "animation
     * interrupt" events.
     */
    PageScrollInstance.prototype.detachInterruptListeners = function () {
        var _this = this;
        PageScrollConfig._interruptEvents.forEach(function (event) { return _this.document.body.removeEventListener(event, _this._interruptListener); });
        this._interruptListenersAttached = false;
    };
    Object.defineProperty(PageScrollInstance.prototype, "namespace", {
        get: function () {
            return this._namespace;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "scrollTarget", {
        get: function () {
            return this._scrollTarget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "verticalScrolling", {
        get: function () {
            return this._verticalScrolling;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "scrollingViews", {
        get: function () {
            return this._scrollingViews;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "startScrollPosition", {
        get: function () {
            return this._startScrollPosition;
        },
        set: function (value) {
            this._startScrollPosition = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "targetScrollPosition", {
        get: function () {
            return this._targetScrollPosition;
        },
        set: function (value) {
            this._targetScrollPosition = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "distanceToScroll", {
        get: function () {
            return this._distanceToScroll;
        },
        set: function (value) {
            this._distanceToScroll = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "executionDuration", {
        get: function () {
            return this._executionDuration;
        },
        set: function (value) {
            this._executionDuration = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "duration", {
        get: function () {
            return this._duration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "speed", {
        get: function () {
            return this._speed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "easingLogic", {
        get: function () {
            return this._easingLogic;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "interruptible", {
        get: function () {
            return this._interruptible;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "startTime", {
        get: function () {
            return this._startTime;
        },
        set: function (value) {
            this._startTime = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "endTime", {
        get: function () {
            return this._endTime;
        },
        set: function (value) {
            this._endTime = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "timer", {
        get: function () {
            return this._timer;
        },
        set: function (value) {
            this._timer = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageScrollInstance.prototype, "interruptListenersAttached", {
        get: function () {
            return this._interruptListenersAttached;
        },
        enumerable: true,
        configurable: true
    });
    return PageScrollInstance;
}());

var PageScroll = (function () {
    function PageScroll(pageScrollService, router$$1, document) {
        this.pageScrollService = pageScrollService;
        this.router = router$$1;
        this.pageScrollTarget = null;
        this.pageScrollHorizontal = null;
        this.pageScrollOffset = null;
        this.pageScrollDuration = null;
        this.pageScrollSpeed = null;
        this.pageScrollEasing = null;
        this.pageScrollAdjustHash = false;
        this.pageScroll = null;
        this.pageScrollFinish = new core.EventEmitter();
        this.document = document;
    }
    PageScroll.prototype.ngOnChanges = function (changes) {
        // Some inputs changed, reset the pageScrollInstance
        this.pageScrollInstance = undefined;
    };
    PageScroll.prototype.ngOnDestroy = function () {
        if (this.pageScrollInstance) {
            this.pageScrollService.stop(this.pageScrollInstance);
        }
        return undefined;
    };
    PageScroll.prototype.generatePageScrollInstance = function () {
        if (PageScrollUtilService.isUndefinedOrNull(this.pageScrollInstance)) {
            this.pageScrollInstance = PageScrollInstance.newInstance({
                document: this.document,
                scrollTarget: this.pageScrollTarget || this.href,
                scrollingViews: null,
                namespace: this.pageScroll,
                verticalScrolling: !this.pageScrollHorizontal,
                pageScrollOffset: this.pageScrollOffset,
                pageScrollInterruptible: this.pageScrollInterruptible,
                pageScrollEasingLogic: this.pageScrollEasing,
                pageScrollDuration: this.pageScrollDuration,
                pageScrollSpeed: this.pageScrollSpeed,
                pageScrollFinishListener: this.pageScrollFinish
            });
        }
        return this.pageScrollInstance;
    };
    PageScroll.prototype.pushRouterState = function () {
        if (this.pageScrollAdjustHash && typeof this.pageScrollInstance.scrollTarget === 'string'
            && this.pageScrollInstance.scrollTarget.substr(0, 1) === '#') {
            // "Navigate" to the current route again and this time set the fragment/hash
            this.router.navigate([], {
                fragment: this.pageScrollInstance.scrollTarget.substr(1),
                preserveQueryParams: true
            });
        }
    };
    PageScroll.prototype.scroll = function () {
        var pageScrollInstance = this.generatePageScrollInstance();
        this.pushRouterState();
        this.pageScrollService.start(pageScrollInstance);
    };
    PageScroll.prototype.handleClick = function (clickEvent) {
        var _this = this;
        if (this.routerLink && this.router !== null && this.router !== undefined) {
            var urlTree = void 0;
            if (typeof this.routerLink === 'string') {
                urlTree = this.router.parseUrl(this.routerLink);
            }
            else {
                urlTree = this.router.createUrlTree(this.routerLink);
            }
            if (!this.router.isActive(urlTree, true)) {
                // We need to navigate their first.
                // Navigation is handled by the routerLink directive
                // so we only need to listen for route change
                var subscription_1 = this.router.events.subscribe(function (routerEvent) {
                    if (routerEvent instanceof router.NavigationEnd) {
                        subscription_1.unsubscribe();
                        // use a timeout to start scrolling as soon as the stack is cleared
                        setTimeout(function () {
                            _this.scroll();
                        }, 0);
                    }
                    else if (routerEvent instanceof router.NavigationError || routerEvent instanceof router.NavigationCancel) {
                        subscription_1.unsubscribe();
                    }
                });
                return false; // to preventDefault()
            }
        }
        this.scroll();
        return false; // to preventDefault()
    };
    /** @nocollapse */
    PageScroll.ctorParameters = function () { return [
        { type: PageScrollService, },
        { type: router.Router, decorators: [{ type: core.Optional },] },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
    ]; };
    PageScroll.propDecorators = {
        'routerLink': [{ type: core.Input },],
        'href': [{ type: core.Input },],
        'pageScrollTarget': [{ type: core.Input },],
        'pageScrollHorizontal': [{ type: core.Input },],
        'pageScrollOffset': [{ type: core.Input },],
        'pageScrollDuration': [{ type: core.Input },],
        'pageScrollSpeed': [{ type: core.Input },],
        'pageScrollEasing': [{ type: core.Input },],
        'pageScrollInterruptible': [{ type: core.Input },],
        'pageScrollAdjustHash': [{ type: core.Input },],
        'pageScroll': [{ type: core.Input },],
        'pageScrollFinish': [{ type: core.Output },],
    };
PageScroll.ɵfac = function PageScroll_Factory(t) { return new (t || PageScroll)(ɵngcc0.ɵɵdirectiveInject(PageScrollService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Router, 8), ɵngcc0.ɵɵdirectiveInject(common.DOCUMENT)); };
PageScroll.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PageScroll, selectors: [["", "pageScroll", ""]], hostBindings: function PageScroll_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function PageScroll_click_HostBindingHandler($event) { return ctx.handleClick($event); });
    } }, inputs: { pageScrollTarget: "pageScrollTarget", pageScrollHorizontal: "pageScrollHorizontal", pageScrollOffset: "pageScrollOffset", pageScrollDuration: "pageScrollDuration", pageScrollSpeed: "pageScrollSpeed", pageScrollEasing: "pageScrollEasing", pageScrollAdjustHash: "pageScrollAdjustHash", pageScroll: "pageScroll", routerLink: "routerLink", href: "href", pageScrollInterruptible: "pageScrollInterruptible" }, outputs: { pageScrollFinish: "pageScrollFinish" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PageScroll, [{
        type: core.Directive,
        args: [{
                selector: '[pageScroll]',
                host: {
                    '(click)': 'handleClick($event)'
                }
            }]
    }], function () { return [{ type: PageScrollService }, { type: ɵngcc1.Router, decorators: [{
                type: core.Optional
            }] }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [common.DOCUMENT]
            }] }]; }, { pageScrollTarget: [{
            type: core.Input
        }], pageScrollHorizontal: [{
            type: core.Input
        }], pageScrollOffset: [{
            type: core.Input
        }], pageScrollDuration: [{
            type: core.Input
        }], pageScrollSpeed: [{
            type: core.Input
        }], pageScrollEasing: [{
            type: core.Input
        }], pageScrollAdjustHash: [{
            type: core.Input
        }], pageScroll: [{
            type: core.Input
        }], pageScrollFinish: [{
            type: core.Output
        }], routerLink: [{
            type: core.Input
        }], href: [{
            type: core.Input
        }], pageScrollInterruptible: [{
            type: core.Input
        }] }); })();
    return PageScroll;
}());

var Ng2PageScrollModule = (function () {
    function Ng2PageScrollModule() {
    }
    /** @deprecated since v4.0.0-beta.10 (https://github.com/Nolanus/ng2-page-scroll/pull/190) */
    Ng2PageScrollModule.forRoot = function () {
        return {
            ngModule: Ng2PageScrollModule,
            providers: [
                { provide: PageScrollService, useClass: PageScrollService }
            ]
        };
    };
    /** @nocollapse */
    Ng2PageScrollModule.ctorParameters = function () { return []; };
Ng2PageScrollModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: Ng2PageScrollModule });
Ng2PageScrollModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function Ng2PageScrollModule_Factory(t) { return new (t || Ng2PageScrollModule)(); }, providers: [NG2PAGESCROLL_SERVICE_PROVIDER], imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(Ng2PageScrollModule, { declarations: [PageScroll], imports: [ɵngcc2.CommonModule], exports: [PageScroll] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Ng2PageScrollModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [PageScroll],
                exports: [PageScroll],
                providers: [NG2PAGESCROLL_SERVICE_PROVIDER]
            }]
    }], function () { return []; }, null); })();
    return Ng2PageScrollModule;
}());

exports.PageScroll = PageScroll;
exports.PageScrollService = PageScrollService;
exports.NG2PAGESCROLL_SERVICE_PROVIDER_FACTORY = NG2PAGESCROLL_SERVICE_PROVIDER_FACTORY;
exports.NG2PAGESCROLL_SERVICE_PROVIDER = NG2PAGESCROLL_SERVICE_PROVIDER;
exports.EasingLogic = EasingLogic;
exports.PageScrollConfig = PageScrollConfig;
exports.PageScrollInstance = PageScrollInstance;
exports.PageScrollUtilService = PageScrollUtilService;
exports.Ng2PageScrollModule = Ng2PageScrollModule;

Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmcyLXBhZ2Utc2Nyb2xsLnVtZC5qcyIsInNvdXJjZXMiOlsibmcyLXBhZ2Utc2Nyb2xsLnVtZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTt1SkFDd0U7MEdBQ2xCOzJEQUM1Qzt3Q0FDUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQ0FvVnVCLEFBR3BDOzs7Ozs7O2dEQUU0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BeWU1RCxBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFvQkE7Ozs7Ozs7Ozs7Ozs7OztNQWVBLEFBUUE7Ozs7Ozs7Ozs7Ozs7O2dEQUU4RCIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpLCByZXF1aXJlKCdAYW5ndWxhci9yb3V0ZXInKSwgcmVxdWlyZSgnQGFuZ3VsYXIvY29tbW9uJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb3JlJywgJ0Bhbmd1bGFyL3JvdXRlcicsICdAYW5ndWxhci9jb21tb24nXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLm5nMiA9IGdsb2JhbC5uZzIgfHwge30sIGdsb2JhbC5uZzIucGFnZSA9IGdsb2JhbC5uZzIucGFnZSB8fCB7fSwgZ2xvYmFsLm5nMi5wYWdlLnNjcm9sbCA9IHt9KSxnbG9iYWwubmcuY29yZSxnbG9iYWwubmcucm91dGVyLGdsb2JhbC5uZy5jb21tb24pKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLGNvcmUscm91dGVyLGNvbW1vbikgeyAndXNlIHN0cmljdCc7XG5cbnZhciBFYXNpbmdMb2dpYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWFzaW5nTG9naWMoKSB7XG4gICAgfVxuICAgIHJldHVybiBFYXNpbmdMb2dpYztcbn0oKSk7XG52YXIgUGFnZVNjcm9sbENvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFnZVNjcm9sbENvbmZpZygpIHtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhZ2VTY3JvbGxDb25maWcsIFwiZGVmYXVsdEVhc2luZ0xvZ2ljXCIsIHtcbiAgICAgICAgLy8gR2V0dGVyIGFuZCBzZXR0ZXIgdG8gYXZvaWQgYXV0byBjb21wbGV0aW9uIHRvIHN1Z2dlc3QgY2FsbGluZyB0aGUgbWV0aG9kXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFBhZ2VTY3JvbGxDb25maWcuX2Vhc2luZ0xvZ2ljO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlYXNpbmdMb2dpYykge1xuICAgICAgICAgICAgUGFnZVNjcm9sbENvbmZpZy5fZWFzaW5nTG9naWMgPSBlYXNpbmdMb2dpYztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCB0aWxsIHVwZGF0aW5nIHRoZSBzY3JvbGwgcG9zaXRpb24gYWdhaW4uXG4gICAgICogU21hbGwgYW1vdW50cyBtYXkgcHJvZHVjZSBzbW9vdGhlciBhbmltYXRpb25zIGJ1dCByZXF1aXJlIG1vcmUgcHJvY2Vzc2luZyBwb3dlci5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUGFnZVNjcm9sbENvbmZpZy5faW50ZXJ2YWwgPSAxMDtcbiAgICAvKipcbiAgICAgKiBUaGUgYW1vdW50IG9mIHBpeGVscyB0aGF0IG5lZWQgdG8gYmUgYmV0d2VlbiB0aGUgY3VycmVudCBzY3JvbGxUb3Avc2Nyb2xsTGVmdCBwb3NpdGlvblxuICAgICAqIGFuZCB0aGUgdGFyZ2V0IHBvc2l0aW9uIHRoZSBjYXVzZSBhIHNjcm9sbCBhbmltYXRpb24uIEluIGNhc2UgZGlzdGFuY2UgaXMgYmVsb3dcbiAgICAgKiB0aGlzIHRocmVzaG9sZCwgYW4gaW1tZWRpYXRlIGp1bXAgd2lsbCBiZSBwZXJmb3JtZWQuXG4gICAgICogRHVlIHRvIGRwaSBvciByb3VuZGluZyBpcnJlZ3VsYXJpdGllcyBpbiBicm93c2VycyBmbG9hdGluZyBwb2ludCBudW1iZXJzIGZvciBzY3JvbGxUb3Avc2Nyb2xsTGVmdCB2YWx1ZXNcbiAgICAgKiBhcmUgcG9zc2libGUsIG1ha2luZyBhID09PSBjb21wYXJpc29uIG9mIGN1cnJlbnQgc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQgYW5kIHRhcmdldCBzY3JvbGxQb3NpdGlvbiBlcnJvci1wcm9uZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUGFnZVNjcm9sbENvbmZpZy5fbWluU2Nyb2xsRGlzdGFuY2UgPSAyO1xuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIGRlZmF1bHQgbmFtZXNwYWNlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQYWdlU2Nyb2xsQ29uZmlnLl9kZWZhdWx0TmFtZXNwYWNlID0gJ2RlZmF1bHQnO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYnkgZGVmYXVsdCB0aGUgc2Nyb2xsaW5nIHNob3VsZCBoYXBwZW4gaW4gdmVydGljYWwgZGlyZWN0aW9uIChieSBtYW5pcHVsYXRpbmcgdGhlIHNjcm9sbFRvcCBwcm9wZXJ0eSlcbiAgICAgKiAoPSB0cnVlOyBkZWZhdWx0KSBvciBpbiBob3Jpem9udGFsIGRpcmVjdGlvbiAoYnkgbWFuaXB1bGF0aW5nIHRoZSBzY3JvbGxMZWZ0IHByb3BlcnR5KSAoPSBmYWxzZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIFBhZ2VTY3JvbGxDb25maWcuZGVmYXVsdElzVmVydGljYWxTY3JvbGxpbmcgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEhvdyBtYW55IGNvbnNvbGUgbG9ncyBzaG91bGQgYmUgZW1pdHRlZC4gQWxzbyBpbmZsdWVuY2VkIGJ5IGFuZ3VsYXIgbW9kZSAoZGV2IG9yIHByb2QgbW9kZSlcbiAgICAgKiAwOiBObyBsb2dzLCBuZWl0aGVyIGluIGRldiBub3IgaW4gcHJvZCBtb2RlXG4gICAgICogMTogQW5pbWF0aW9uIGVycm9ycyBpbiBkZXYgbW9kZSwgbm8gbG9ncyBpbiBwcm9kIG1vZGVcbiAgICAgKiAyOiBBbmltYXRpb24gZXJyb3JzIGluIGRldiBhbmQgcHJvZCBtb2RlXG4gICAgICogNTogQW5pbWF0aW9uIGVycm9ycyBpbiBkZXYgYW5kIGFsbCBzY3JvbGwgcG9zaXRpb24gdmFsdWVzIHRoYXQgZ2V0IHNldDsgYW5pbWF0aW9uIGVycm9ycyBpbiBwcm9kIG1vZGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBhZ2VTY3JvbGxDb25maWcuX2xvZ0xldmVsID0gMjtcbiAgICAvKipcbiAgICAgKiBUaGUgZHVyYXRpb24gaG93IGxvbmcgYSBzY3JvbGxUbyBhbmltYXRpb24gc2hvdWxkIGxhc3QgYnkgZGVmYXVsdC5cbiAgICAgKiBNYXkgYmUgb3ZlcnJpZGRlbiB1c2luZyB0aGUgcGFnZS1zY3JvbGwtZHVyYXRpb24gYXR0cmlidXRlIG9uIGEgc2luZ2xlIG5nMlBhZ2VTY3JvbGwgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBQYWdlU2Nyb2xsQ29uZmlnLmRlZmF1bHREdXJhdGlvbiA9IDEyNTA7XG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIGluIHBpeGVscyBhYm92ZSBzY3JvbGwgdGFyZ2V0IHdoZXJlIHRoZSBhbmltYXRpb24gc2hvdWxkIHN0b3AuIFNldHRpbmcgYSBwb3NpdGl2ZSBudW1iZXIgcmVzdWx0cyBpblxuICAgICAqIHRoZSBzY3JvbGwgdGFyZ2V0IGJlaW5nIG1vcmUgaW4gdGhlIG1pZGRsZSBvZiB0aGUgc2NyZWVuLCBuZWdhdGl2ZSBudW1iZXJzIHdpbGwgcHJvZHVjZSBzY3JvbGxpbmcgXCJ0b28gZmFyXCJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIFBhZ2VTY3JvbGxDb25maWcuZGVmYXVsdFNjcm9sbE9mZnNldCA9IDA7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBieSBkZWZhdWx0IGZvciBpbmxpbmUgc2Nyb2xsIGFuaW1hdGlvbnMgdGhlIGFkdmFuY2VkIG9mZnNldCBjYWxjdWxhdGlvbiBzaG91bGQgdGFrZSBwbGFjZSAodHJ1ZSkgb3JcbiAgICAgKiBub3QgKGZhbHNlKS4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICAgKiBUaGUgYWR2YW5jZWQgb2Zmc2V0IGNhbGN1bGF0aW9uIHdpbGwgdHJhdmVyc2UgdGhlIERPTSB0cmVlIHVwd2FyZHMsIHN0YXJ0aW5nIGF0IHRoZSBzY3JvbGxUYXJnZXQsIHVudGlsIGl0IGZpbmRzXG4gICAgICogdGhlIHNjcm9sbGluZ1ZpZXcgY29udGFpbmVyIGVsZW1lbnQuIEFsb25nIHRoZSB3YXkgdGhlIG9mZnNldCBwb3NpdGlvbnMgb2YgdGhlIHJlbGF0aXZlIHBvc2l0aW9uZWRcbiAgICAgKiAocG9zaXRpb246IHJlbGF0aXZlKSBlbGVtZW50cyB3aWxsIGJlIHRha2VuIGludG8gYWNjb3VudCBmb3IgY2FsY3VsYXRpbmcgdGhlIHRhcmdldCBlbGVtZW50cyBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBQYWdlU2Nyb2xsQ29uZmlnLmRlZmF1bHRBZHZhbmNlZElubGluZU9mZnNldENhbGN1bGF0aW9uID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50cyB0aGF0IGFyZSBsaXN0ZW5lZCB0byBvbiB0aGUgYm9keSB0byBkZWNpZGUgd2hldGhlciBhIHNjcm9sbCBhbmltYXRpb24gaGFzIGJlZW4gaW50ZXJmZXJlZC9pbnRlcnJ1cHRlZCBieSB0aGUgdXNlclxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBhZ2VTY3JvbGxDb25maWcuX2ludGVycnVwdEV2ZW50cyA9IFsnbW91c2Vkb3duJywgJ3doZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgJ21vdXNld2hlZWwnLCAna2V5dXAnLCAndG91Y2htb3ZlJ107XG4gICAgLyoqXG4gICAgICogVGhlIGtleXMgdGhhdCBhcmUgY29uc2lkZXJlZCB0byBpbnRlcnJ1cHQgYSBzY3JvbGwgYW5pbWF0aW9uIChtYWlubHkgdGhlIGFycm93IGtleXMpLiBBbGwgb3RoZXIga2V5IHByZXNzZXMgd2lsbCBub3Qgc3RvcCB0aGVcbiAgICAgKiBzY3JvbGwgYW5pbWF0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBhZ2VTY3JvbGxDb25maWcuX2ludGVycnVwdEtleXMgPSBbMzMsIDM0LCAzNSwgMzYsIDM4LCA0MF07XG4gICAgLyoqXG4gICAgICogV2hldGhlciBhIHNjcm9sbCBhbmltYXRpb24gc2hvdWxkIGJlIGludGVycnVwdGlibGUgYnkgdXNlciBpbnRlcmFjdGlvbiAodHJ1ZSkgb3Igbm90IChmYWxzZSkuIElmIHRoZSB1c2VyIHBlcmZvcm1zIGFuXG4gICAgICogaW50ZXJydXB0aW5nIGV2ZW50IHdoaWxlIGEgc2Nyb2xsIGFuaW1hdGlvbiB0YWtlcyBwbGFjZSwgdGhlIHNjcm9sbCBhbmltYXRpb24gc3RvcHMuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgUGFnZVNjcm9sbENvbmZpZy5kZWZhdWx0SW50ZXJydXB0aWJsZSA9IHRydWU7XG4gICAgUGFnZVNjcm9sbENvbmZpZy5fZWFzaW5nTG9naWMgPSB7XG4gICAgICAgIGVhc2U6IGZ1bmN0aW9uICh0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICAvLyBMaW5lYXIgZWFzaW5nXG4gICAgICAgICAgICByZXR1cm4gYyAqIHQgLyBkICsgYjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFBhZ2VTY3JvbGxDb25maWc7XG59KCkpO1xuXG52YXIgUGFnZVNjcm9sbFV0aWxTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWdlU2Nyb2xsVXRpbFNlcnZpY2UoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFV0aWwgbWV0aG9kIHRvIGNoZWNrIHdoZXRoZXIgYSBnaXZlbiB2YXJpYWJsZSBpcyBlaXRoZXIgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgKi9cbiAgICBQYWdlU2Nyb2xsVXRpbFNlcnZpY2UuaXNVbmRlZmluZWRPck51bGwgPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFyaWFibGUgPT09ICd1bmRlZmluZWQnKSB8fCB2YXJpYWJsZSA9PT0gdW5kZWZpbmVkIHx8IHZhcmlhYmxlID09PSBudWxsO1xuICAgIH07XG4gICAgUGFnZVNjcm9sbFV0aWxTZXJ2aWNlLmV4dHJhY3RFbGVtZW50UG9zaXRpb24gPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHNjcm9sbFRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICB2YXIgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHZhciB3aW5kb3dQYWdlWU9mZnNldCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LnBhZ2VZT2Zmc2V0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHdpbmRvd1BhZ2VYT2Zmc2V0ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcucGFnZVhPZmZzZXQgfHwgdW5kZWZpbmVkO1xuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gd2luZG93UGFnZVlPZmZzZXQgfHwgZG9jRWwuc2Nyb2xsVG9wIHx8IGJvZHkuc2Nyb2xsVG9wO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHdpbmRvd1BhZ2VYT2Zmc2V0IHx8IGRvY0VsLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgY2xpZW50VG9wID0gZG9jRWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG4gICAgICAgIHZhciBjbGllbnRMZWZ0ID0gZG9jRWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMDtcbiAgICAgICAgaWYgKFBhZ2VTY3JvbGxVdGlsU2VydmljZS5pc1VuZGVmaW5lZE9yTnVsbChzY3JvbGxUYXJnZXRFbGVtZW50KSkge1xuICAgICAgICAgICAgLy8gTm8gZWxlbWVudCBmb3VuZCwgc28gcmV0dXJuIHRoZSBjdXJyZW50IHBvc2l0aW9uIHRvIG5vdCBjYXVzZSBhbnkgY2hhbmdlIGluIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiBzY3JvbGxUb3AsIGxlZnQ6IHNjcm9sbExlZnQgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm94ID0gc2Nyb2xsVGFyZ2V0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHRvcCA9IGJveC50b3AgKyBzY3JvbGxUb3AgLSBjbGllbnRUb3A7XG4gICAgICAgIHZhciBsZWZ0ID0gYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdDtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiBNYXRoLnJvdW5kKHRvcCksIGxlZnQ6IE1hdGgucm91bmQobGVmdCkgfTtcbiAgICB9O1xuICAgIHJldHVybiBQYWdlU2Nyb2xsVXRpbFNlcnZpY2U7XG59KCkpO1xuXG52YXIgUGFnZVNjcm9sbFNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhZ2VTY3JvbGxTZXJ2aWNlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJ1bm5pbmdJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5vbkludGVycnVwdGVkID0ge1xuICAgICAgICAgICAgcmVwb3J0OiBmdW5jdGlvbiAoZXZlbnQsIHBhZ2VTY3JvbGxJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICghcGFnZVNjcm9sbEluc3RhbmNlLmludGVycnVwdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm9uLWludGVycnVwdGlibGUgYW55d2F5LCBzbyBkbyBub3Qgc3RvcCBhbnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzaG91bGRTdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHN0b3AgaWYgc3BlY2lmaWMga2V5cyBoYXZlIGJlZW4gcHJlc3NlZCwgZm9yIGFsbCBvdGhlcnMgZG9uJ3Qgc3RvcCBhbnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoUGFnZVNjcm9sbENvbmZpZy5faW50ZXJydXB0S2V5cy5pbmRleE9mKGV2ZW50LmtleUNvZGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByZXNzZWQga2V5IGlzIG5vdCBpbiB0aGUgbGlzdCBvZiBpbnRlcnJ1cHRpbmcga2V5c1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBtb3VzZWRvd24gZXZlbnRzIHdlIG9ubHkgc3RvcCB0aGUgc2Nyb2xsIGFuaW1hdGlvbiBvZiB0aGUgbW91c2UgaGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZW4gY2xpY2tlZCBpbnNpZGUgdGhlIHNjcm9sbGluZyBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYWdlU2Nyb2xsSW5zdGFuY2Uuc2Nyb2xsaW5nVmlld3Muc29tZShmdW5jdGlvbiAoc2Nyb2xsaW5nVmlldykgeyByZXR1cm4gc2Nyb2xsaW5nVmlldy5jb250YWlucyhldmVudC50YXJnZXQpOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW91c2UgY2xpY2tlZCBhbiBlbGVtZW50IHdoaWNoIGlzIG5vdCBpbnNpZGUgYW55IG9mIHRoZSB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFN0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdG9wQWxsKHBhZ2VTY3JvbGxJbnN0YW5jZS5uYW1lc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFBhZ2VTY3JvbGxTZXJ2aWNlLmluc3RhbmNlQ291bnRlciA+IDAgJiZcbiAgICAgICAgICAgIChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAyIHx8IChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAxICYmIGNvcmUuaXNEZXZNb2RlKCkpKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdBbiBpbnN0YW5jZSBvZiBQYWdlU2Nyb2xsU2VydmljZSBhbHJlYWR5IGV4aXN0cywgdXN1YWxseSAnICtcbiAgICAgICAgICAgICAgICAnaW5jbHVkaW5nIG9uZSBwcm92aWRlciBzaG91bGQgYmUgZW5vdWdoLCBzbyBkb3VibGUgY2hlY2suJyk7XG4gICAgICAgIH1cbiAgICAgICAgUGFnZVNjcm9sbFNlcnZpY2UuaW5zdGFuY2VDb3VudGVyKys7XG4gICAgfVxuICAgIFBhZ2VTY3JvbGxTZXJ2aWNlLnByb3RvdHlwZS5zdG9wSW50ZXJuYWwgPSBmdW5jdGlvbiAoaW50ZXJydXB0ZWQsIHBhZ2VTY3JvbGxJbnN0YW5jZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnJ1bm5pbmdJbnN0YW5jZXMuaW5kZXhPZihwYWdlU2Nyb2xsSW5zdGFuY2UpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nSW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZ2VTY3JvbGxJbnN0YW5jZS5pbnRlcnJ1cHRMaXN0ZW5lcnNBdHRhY2hlZCkge1xuICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLmRldGFjaEludGVycnVwdExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWdlU2Nyb2xsSW5zdGFuY2UudGltZXIpIHtcbiAgICAgICAgICAgIC8vIENsZWFyL1N0b3AgdGhlIHRpbWVyXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHBhZ2VTY3JvbGxJbnN0YW5jZS50aW1lcik7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgcmVmZXJlbmNlIHRvIHRoaXMgdGltZXJcbiAgICAgICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS50aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5maXJlRXZlbnQoIWludGVycnVwdGVkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgc2Nyb2xsIGFuaW1hdGlvbi4gQWxsIHByb3BlcnRpZXMgb2YgdGhlIGFuaW1hdGlvbiBhcmUgc3RvcmVkIGluIHRoZSBnaXZlbiB7QGxpbmsgUGFnZVNjcm9sbEluc3RhbmNlfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBjb3JlIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHdob2xlIGxpYnJhcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFnZVNjcm9sbEluc3RhbmNlXG4gICAgICovXG4gICAgUGFnZVNjcm9sbFNlcnZpY2UucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHBhZ2VTY3JvbGxJbnN0YW5jZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBTdG9wIGFsbCBwb3NzaWJseSBydW5uaW5nIHNjcm9sbCBhbmltYXRpb25zIGluIHRoZSBzYW1lIG5hbWVzcGFjZVxuICAgICAgICB0aGlzLnN0b3BBbGwocGFnZVNjcm9sbEluc3RhbmNlLm5hbWVzcGFjZSk7XG4gICAgICAgIGlmIChwYWdlU2Nyb2xsSW5zdGFuY2Uuc2Nyb2xsaW5nVmlld3MgPT09IG51bGwgfHwgcGFnZVNjcm9sbEluc3RhbmNlLnNjcm9sbGluZ1ZpZXdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTm8gc2Nyb2xsaW5nVmlld3Mgc3BlY2lmaWVkLCB0aHVzIHdlIGNhbid0IGFuaW1hdGUgYW55dGhpbmdcbiAgICAgICAgICAgIGlmIChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAyIHx8IChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAxICYmIGNvcmUuaXNEZXZNb2RlKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyBzY3JvbGxpbmdWaWV3cyBzcGVjaWZpZWQsIHRoaXMgbmcyLXBhZ2Utc2Nyb2xsIGRvZXMgbm90IGtub3cgd2hpY2ggRE9NIGVsZW1lbnRzIHRvIHNjcm9sbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydFNjcm9sbFBvc2l0aW9uRm91bmQgPSBmYWxzZTtcbiAgICAgICAgLy8gUmVzZXQgc3RhcnQgc2Nyb2xsIHBvc2l0aW9uIHRvIDAuIElmIGFueSBvZiB0aGUgc2Nyb2xsaW5nVmlld3MgaGFzIGEgZGlmZmVyZW50IG9uZSwgaXQgd2lsbCBiZSBleHRyYWN0ZWQgbmV4dFxuICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2Uuc3RhcnRTY3JvbGxQb3NpdGlvbiA9IDA7XG4gICAgICAgIC8vIEdldCB0aGUgc3RhcnQgc2Nyb2xsIHBvc2l0aW9uIGZyb20gdGhlIHNjcm9sbGluZ1ZpZXdzIChlLmcuIGlmIHRoZSB1c2VyIGFscmVhZHkgc2Nyb2xsZWQgZG93biB0aGUgY29udGVudClcbiAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLnNjcm9sbGluZ1ZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbGluZ1ZpZXcpIHtcbiAgICAgICAgICAgIGlmIChQYWdlU2Nyb2xsVXRpbFNlcnZpY2UuaXNVbmRlZmluZWRPck51bGwoc2Nyb2xsaW5nVmlldykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0IHZhbHVlIG9mIHRoZSBmaXJzdCBzY3JvbGxpbmdWaWV3IHRoYXQgcmV0dXJucyBhIHZhbHVlIGZvciBpdHMgXCJzY3JvbGxUb3BcIlxuICAgICAgICAgICAgLy8gb3IgXCJzY3JvbGxMZWZ0XCIgcHJvcGVydHkgdGhhdCBpcyBub3QgdW5kZWZpbmVkIGFuZCB1bmVxdWFsIHRvIDBcbiAgICAgICAgICAgIHZhciBzY3JvbGxQb3NpdGlvbiA9IHBhZ2VTY3JvbGxJbnN0YW5jZS5nZXRTY3JvbGxQcm9wZXJ0eVZhbHVlKHNjcm9sbGluZ1ZpZXcpO1xuICAgICAgICAgICAgaWYgKCFzdGFydFNjcm9sbFBvc2l0aW9uRm91bmQgJiYgc2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHNjcm9sbGluZ1ZpZXcgdGhhdCBkb2VzIG5vdCBoYXZlIHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0IDBcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNjcm9sbCBwb3NpdGlvbiB2YWx1ZSwgYXMgdGhpcyB3aWxsIGJlIG91ciBzdGFydFNjcm9sbFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLnN0YXJ0U2Nyb2xsUG9zaXRpb24gPSBzY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBzdGFydFNjcm9sbFBvc2l0aW9uRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhZ2VTY3JvbGxPZmZzZXQgPSBwYWdlU2Nyb2xsSW5zdGFuY2UuZ2V0Q3VycmVudE9mZnNldCgpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHRhcmdldCBwb3NpdGlvbiB0aGF0IHRoZSBzY3JvbGwgYW5pbWF0aW9uIHNob3VsZCBnbyB0b1xuICAgICAgICB2YXIgc2Nyb2xsVGFyZ2V0UG9zaXRpb24gPSBwYWdlU2Nyb2xsSW5zdGFuY2UuZXh0cmFjdFNjcm9sbFRhcmdldFBvc2l0aW9uKCk7XG4gICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS50YXJnZXRTY3JvbGxQb3NpdGlvbiA9IE1hdGgucm91bmQoKHBhZ2VTY3JvbGxJbnN0YW5jZS52ZXJ0aWNhbFNjcm9sbGluZyA/IHNjcm9sbFRhcmdldFBvc2l0aW9uLnRvcCA6IHNjcm9sbFRhcmdldFBvc2l0aW9uLmxlZnQpIC0gcGFnZVNjcm9sbE9mZnNldCk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugd2UgbmVlZCB0byBnbyBpbiB0b3RhbFxuICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuZGlzdGFuY2VUb1Njcm9sbCA9IHBhZ2VTY3JvbGxJbnN0YW5jZS50YXJnZXRTY3JvbGxQb3NpdGlvbiAtIHBhZ2VTY3JvbGxJbnN0YW5jZS5zdGFydFNjcm9sbFBvc2l0aW9uO1xuICAgICAgICBpZiAoaXNOYU4ocGFnZVNjcm9sbEluc3RhbmNlLmRpc3RhbmNlVG9TY3JvbGwpKSB7XG4gICAgICAgICAgICAvLyBXZSB3ZXJlbid0IGFibGUgdG8gZmluZCB0aGUgdGFyZ2V0IHBvc2l0aW9uLCBtYXliZSB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdD9cbiAgICAgICAgICAgIGlmIChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAyIHx8IChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAxICYmIGNvcmUuaXNEZXZNb2RlKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1Njcm9sbGluZyBub3QgcG9zc2libGUsIGFzIHdlIGNhblxcJ3QgZmluZCB0aGUgc3BlY2lmaWVkIHRhcmdldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLmZpcmVFdmVudChmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UncmUgYXQgdGhlIGZpbmFsIGRlc3RpbmF0aW9uIGFscmVhZHlcbiAgICAgICAgLy8gT1Igd2UgbmVlZCB0byBzY3JvbGwgZG93biBidXQgYXJlIGFscmVhZHkgYXQgdGhlIGVuZFxuICAgICAgICAvLyBPUiB3ZSBuZWVkIHRvIHNjcm9sbCB1cCBidXQgYXJlIGF0IHRoZSB0b3AgYWxyZWFkeVxuICAgICAgICB2YXIgYWxsUmVhZHlBdERlc3RpbmF0aW9uID0gTWF0aC5hYnMocGFnZVNjcm9sbEluc3RhbmNlLmRpc3RhbmNlVG9TY3JvbGwpIDwgUGFnZVNjcm9sbENvbmZpZy5fbWluU2Nyb2xsRGlzdGFuY2U7XG4gICAgICAgIC8vIENoZWNrIGhvdyBsb25nIHdlIG5lZWQgdG8gc2Nyb2xsIGlmIGEgc3BlZWQgb3B0aW9uIGlzIGdpdmVuXG4gICAgICAgIC8vIERlZmF1bHQgZXhlY3V0aW9uRHVyYXRpb24gaXMgdGhlIHNwZWNpZmllZCBkdXJhdGlvblxuICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuZXhlY3V0aW9uRHVyYXRpb24gPSBwYWdlU2Nyb2xsSW5zdGFuY2UuZHVyYXRpb247XG4gICAgICAgIC8vIE1heWJlIHdlIG5lZWQgdG8gcGF5IGF0dGVudGlvbiB0byB0aGUgc3BlZWQgb3B0aW9uP1xuICAgICAgICBpZiAoIVBhZ2VTY3JvbGxVdGlsU2VydmljZS5pc1VuZGVmaW5lZE9yTnVsbChwYWdlU2Nyb2xsSW5zdGFuY2Uuc3BlZWQpICYmIFBhZ2VTY3JvbGxVdGlsU2VydmljZS5pc1VuZGVmaW5lZE9yTnVsbChwYWdlU2Nyb2xsSW5zdGFuY2UuZHVyYXRpb24pKSB7XG4gICAgICAgICAgICAvLyBTcGVlZCBvcHRpb24gaXMgc2V0IGFuZCBubyBkdXJhdGlvbiA9PiBjYWxjdWxhdGUgZHVyYXRpb24gYmFzZWQgb24gc3BlZWQgYW5kIHNjcm9sbCBkaXN0YW5jZVxuICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLmV4ZWN1dGlvbkR1cmF0aW9uID0gTWF0aC5hYnMocGFnZVNjcm9sbEluc3RhbmNlLmRpc3RhbmNlVG9TY3JvbGwpIC8gcGFnZVNjcm9sbEluc3RhbmNlLnNwZWVkICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBzaG91bGQgZ28gdGhlcmUgZGlyZWN0bHksIGFzIG91ciBcImFuaW1hdGlvblwiIHdvdWxkIGhhdmUgb25lIGJpZyBzdGVwXG4gICAgICAgIC8vIG9ubHkgYW55d2F5IGFuZCB0aGlzIHdheSB3ZSBzYXZlIHRoZSBpbnRlcnZhbCBzdHVmZlxuICAgICAgICB2YXIgdG9vU2hvcnRJbnRlcnZhbCA9IHBhZ2VTY3JvbGxJbnN0YW5jZS5leGVjdXRpb25EdXJhdGlvbiA8PSBQYWdlU2Nyb2xsQ29uZmlnLl9pbnRlcnZhbDtcbiAgICAgICAgaWYgKGFsbFJlYWR5QXREZXN0aW5hdGlvbiB8fCB0b29TaG9ydEludGVydmFsKSB7XG4gICAgICAgICAgICBpZiAoUGFnZVNjcm9sbENvbmZpZy5fbG9nTGV2ZWwgPj0gMiB8fCAoUGFnZVNjcm9sbENvbmZpZy5fbG9nTGV2ZWwgPj0gMSAmJiBjb3JlLmlzRGV2TW9kZSgpKSkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxSZWFkeUF0RGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1Njcm9sbGluZyBub3QgcG9zc2libGUsIGFzIHdlIGNhblxcJ3QgZ2V0IGFueSBjbG9zZXIgdG8gdGhlIGRlc3RpbmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2Nyb2xsIGR1cmF0aW9uIHNob3J0ZXIgdGhhdCBpbnRlcnZhbCBsZW5ndGgsIGp1bXBpbmcgdG8gdGFyZ2V0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLnNldFNjcm9sbFBvc2l0aW9uKHBhZ2VTY3JvbGxJbnN0YW5jZS50YXJnZXRTY3JvbGxQb3NpdGlvbik7XG4gICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuZmlyZUV2ZW50KHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBpbnRlcnJ1cHQgbGlzdGVuZXJzIGlmIHdlIHdhbnQgYW4gaW50ZXJydXB0aWJsZSBzY3JvbGwgYW5pbWF0aW9uXG4gICAgICAgIGlmIChwYWdlU2Nyb2xsSW5zdGFuY2UuaW50ZXJydXB0aWJsZSB8fFxuICAgICAgICAgICAgKFBhZ2VTY3JvbGxVdGlsU2VydmljZS5pc1VuZGVmaW5lZE9yTnVsbChwYWdlU2Nyb2xsSW5zdGFuY2UuaW50ZXJydXB0aWJsZSkgJiYgUGFnZVNjcm9sbENvbmZpZy5kZWZhdWx0SW50ZXJydXB0aWJsZSkpIHtcbiAgICAgICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5hdHRhY2hJbnRlcnJ1cHRMaXN0ZW5lcnModGhpcy5vbkludGVycnVwdGVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMZXQncyBnZXQgc3RhcnRlZCwgZ2V0IHRoZSBzdGFydCB0aW1lLi4uXG4gICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgLy8gLi4gYW5kIGNhbGN1bGF0ZSB0aGUgZW5kIHRpbWUgKHdoZW4gd2UgbmVlZCB0byBmaW5pc2ggYXQgbGFzdClcbiAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLmVuZFRpbWUgPSBwYWdlU2Nyb2xsSW5zdGFuY2Uuc3RhcnRUaW1lICsgcGFnZVNjcm9sbEluc3RhbmNlLmV4ZWN1dGlvbkR1cmF0aW9uO1xuICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UudGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoX3BhZ2VTY3JvbGxJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gVGFrZSB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgbmV3IHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgICAgdmFyIG5ld1Njcm9sbFBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHN0b3BOb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChfcGFnZVNjcm9sbEluc3RhbmNlLmVuZFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSdyZSBvdmVyIHRoZSB0aW1lIGFscmVhZHksIHNvIGdvIHRoZSB0YXJnZXRTY3JvbGxQb3NpdGlvbiAoYWthIGRlc3RpbmF0aW9uKVxuICAgICAgICAgICAgICAgIG5ld1Njcm9sbFBvc2l0aW9uID0gX3BhZ2VTY3JvbGxJbnN0YW5jZS50YXJnZXRTY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBzdG9wTm93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IHRpbWUgdXNpbmcgdGhlIGVhc2luZyBmdW5jdGlvblxuICAgICAgICAgICAgICAgIG5ld1Njcm9sbFBvc2l0aW9uID0gTWF0aC5yb3VuZChfcGFnZVNjcm9sbEluc3RhbmNlLmVhc2luZ0xvZ2ljLmVhc2UoY3VycmVudFRpbWUgLSBfcGFnZVNjcm9sbEluc3RhbmNlLnN0YXJ0VGltZSwgX3BhZ2VTY3JvbGxJbnN0YW5jZS5zdGFydFNjcm9sbFBvc2l0aW9uLCBfcGFnZVNjcm9sbEluc3RhbmNlLmRpc3RhbmNlVG9TY3JvbGwsIF9wYWdlU2Nyb2xsSW5zdGFuY2UuZXhlY3V0aW9uRHVyYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB0aGUgbmV3IHNjcm9sbFBvc2l0aW9uIHRvIGFsbCBzY3JvbGxpbmdWaWV3cyBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKCFfcGFnZVNjcm9sbEluc3RhbmNlLnNldFNjcm9sbFBvc2l0aW9uKG5ld1Njcm9sbFBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgdGhlIG5ldyBzY3JvbGxUb3Avc2Nyb2xsTGVmdCB2YWx1ZSBmYWlsZWQgZm9yIGFsbCBTY3JvbGxpbmdWaWV3c1xuICAgICAgICAgICAgICAgIC8vIGVhcmx5IHN0b3AgdGhlIHNjcm9sbCBhbmltYXRpb24gdG8gc2F2ZSByZXNvdXJjZXNcbiAgICAgICAgICAgICAgICBzdG9wTm93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF0IHRoZSBlbmQgZG8gdGhlIGludGVybmFsIHN0b3AgbWFpbnRlbmFuY2UgYW5kIGZpcmUgdGhlIHBhZ2VTY3JvbGxGaW5pc2ggZXZlbnRcbiAgICAgICAgICAgIC8vIChvdGhlcndpc2UgdGhlIGV2ZW50IG1pZ2h0IGFycml2ZSBhdCBcInRvbyBlYXJseVwiKVxuICAgICAgICAgICAgaWYgKHN0b3BOb3cpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdG9wSW50ZXJuYWwoZmFsc2UsIF9wYWdlU2Nyb2xsSW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBQYWdlU2Nyb2xsQ29uZmlnLl9pbnRlcnZhbCwgcGFnZVNjcm9sbEluc3RhbmNlKTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGluc3RhbmNlIGFzIHJ1bm5pbmcgb25lXG4gICAgICAgIHRoaXMucnVubmluZ0luc3RhbmNlcy5wdXNoKHBhZ2VTY3JvbGxJbnN0YW5jZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9wIGFsbCBydW5uaW5nIHNjcm9sbCBhbmltYXRpb25zLiBPcHRpb25hbGx5IGxpbWl0IHRvIHN0b3Agb25seSB0aGUgb25lcyBvZiBzcGVjaWZpYyBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgUGFnZVNjcm9sbFNlcnZpY2UucHJvdG90eXBlLnN0b3BBbGwgPSBmdW5jdGlvbiAobmFtZXNwYWNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmdJbnN0YW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHN0b3BwZWRTb21lID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucnVubmluZ0luc3RhbmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBwYWdlU2Nyb2xsSW5zdGFuY2UgPSB0aGlzLnJ1bm5pbmdJbnN0YW5jZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKFBhZ2VTY3JvbGxVdGlsU2VydmljZS5pc1VuZGVmaW5lZE9yTnVsbChuYW1lc3BhY2UpIHx8IG5hbWVzcGFjZS5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRTb21lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wSW50ZXJuYWwodHJ1ZSwgcGFnZVNjcm9sbEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGNvdW50ZXIsIGFzIHdlIHJlbW92ZWQgYW4gaXRlbSBmcm9tIHRoZSBhcnJheSB3ZSBpdGVyYXRlIG92ZXJcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdG9wcGVkU29tZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBQYWdlU2Nyb2xsU2VydmljZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChwYWdlU2Nyb2xsSW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcEludGVybmFsKHRydWUsIHBhZ2VTY3JvbGxJbnN0YW5jZSk7XG4gICAgfTtcbiAgICBQYWdlU2Nyb2xsU2VydmljZS5pbnN0YW5jZUNvdW50ZXIgPSAwO1xuICAgIFBhZ2VTY3JvbGxTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBQYWdlU2Nyb2xsU2VydmljZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBQYWdlU2Nyb2xsU2VydmljZTtcbn0oKSk7XG4vKiBzaW5nbGV0b24gcGF0dGVybiB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzEzODU0ICovXG5mdW5jdGlvbiBORzJQQUdFU0NST0xMX1NFUlZJQ0VfUFJPVklERVJfRkFDVE9SWShwYXJlbnREaXNwYXRjaGVyKSB7XG4gICAgcmV0dXJuIHBhcmVudERpc3BhdGNoZXIgfHwgbmV3IFBhZ2VTY3JvbGxTZXJ2aWNlKCk7XG59XG52YXIgTkcyUEFHRVNDUk9MTF9TRVJWSUNFX1BST1ZJREVSID0ge1xuICAgIHByb3ZpZGU6IFBhZ2VTY3JvbGxTZXJ2aWNlLFxuICAgIGRlcHM6IFtbbmV3IGNvcmUuT3B0aW9uYWwoKSwgbmV3IGNvcmUuU2tpcFNlbGYoKSwgUGFnZVNjcm9sbFNlcnZpY2VdXSxcbiAgICB1c2VGYWN0b3J5OiBORzJQQUdFU0NST0xMX1NFUlZJQ0VfUFJPVklERVJfRkFDVE9SWVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2Nyb2xsaW5nIGFjdGlvblxuICovXG52YXIgUGFnZVNjcm9sbEluc3RhbmNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGNvbnN0cnVjdG9yLCByZXF1aXJlcyB0aGUgcHJvcGVydGllcyBhc3N1bWVkIHRvIGJlIHRoZSBiYXJlIG1pbmltdW0uXG4gICAgICogVXNlIHRoZSBmYWN0b3J5IG1ldGhvZHMgdG8gY3JlYXRlIGluc3RhbmNlczpcbiAgICAgKiAgICAgIHtAbGluayBQYWdlU2Nyb2xsSW5zdGFuY2Ujc2ltcGxlSW5zdGFuY2V9XG4gICAgICogICAgICB7QGxpbmsgUGFnZVNjcm9sbEluc3RhbmNlI25ld0luc3RhbmNlfVxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYWdlU2Nyb2xsSW5zdGFuY2UobmFtZXNwYWNlLCBkb2N1bWVudCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlIHNldCBkdXJpbmcgaW5zdGFuY2UgY29uc3RydWN0aW9uIGFuZCBkZWZhdWx0IHRvIHRoZWlyIGRlZmF1bHRzIGZyb20gUGFnZVNjcm9sbENvbmZpZ1xuICAgICAgICAgKi9cbiAgICAgICAgLyogQSBuYW1lc3BhY2UgdG8gXCJncm91cFwiIHNjcm9sbCBhbmltYXRpb25zIHRvZ2V0aGVyIGFuZCBzdG9wcGluZyBzb21lIGRvZXMgbm90IHN0b3Agb3RoZXJzICovXG4gICAgICAgIHRoaXMuX25hbWVzcGFjZSA9IFBhZ2VTY3JvbGxDb25maWcuX2RlZmF1bHROYW1lc3BhY2U7XG4gICAgICAgIC8qIFdoZXRoZXIgd2Ugc2Nyb2xsIHZlcnRpY2FsbHkgKHRydWUpIG9yIGhvcml6b250YWxseSAoZmFsc2UpICovXG4gICAgICAgIHRoaXMuX3ZlcnRpY2FsU2Nyb2xsaW5nID0gUGFnZVNjcm9sbENvbmZpZy5kZWZhdWx0SXNWZXJ0aWNhbFNjcm9sbGluZztcbiAgICAgICAgLyogT2Zmc2V0IGluIHB4IHRoYXQgdGhlIGFuaW1hdGlvbiBzaG91bGQgc3RvcCBhYm92ZSB0aGF0IHRhcmdldCBlbGVtZW50ICovXG4gICAgICAgIHRoaXMuX29mZnNldCA9IFBhZ2VTY3JvbGxDb25maWcuZGVmYXVsdFNjcm9sbE9mZnNldDtcbiAgICAgICAgLyogRHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRoZSBzY3JvbGwgYW5pbWF0aW9uIHNob3VsZCBsYXN0ICovXG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gUGFnZVNjcm9sbENvbmZpZy5kZWZhdWx0RHVyYXRpb247XG4gICAgICAgIC8qIEVhc2luZyBmdW5jdGlvbiB0byBtYW5pcHVsYXRlIHRoZSBzY3JvbGxUb3Avc2Nyb2xsTGVmdCB2YWx1ZSBvdmVyIHRpbWUgKi9cbiAgICAgICAgdGhpcy5fZWFzaW5nTG9naWMgPSBQYWdlU2Nyb2xsQ29uZmlnLmRlZmF1bHRFYXNpbmdMb2dpYztcbiAgICAgICAgLyogQm9vbGVhbiB3aGV0aGVyIHRoZSBzY3JvbGwgYW5pbWF0aW9uIHNob3VsZCBzdG9wIG9uIHVzZXIgaW50ZXJydXB0aW9uIG9yIG5vdCAqL1xuICAgICAgICB0aGlzLl9pbnRlcnJ1cHRpYmxlID0gUGFnZVNjcm9sbENvbmZpZy5kZWZhdWx0SW50ZXJydXB0aWJsZTtcbiAgICAgICAgLyogV2hldGhlciB0aGUgYWR2YW5kZWQgb2Zmc2V0IGNhbGN1bGF0aW9uIGZvciBpbmxpbmUgc2Nyb2xsaW5nIHNob3VsZCBiZSB1c2VkICovXG4gICAgICAgIHRoaXMuX2FkdmFuY2VkSW5saW5lT2Zmc2V0Q2FsY3VsYXRpb24gPSBQYWdlU2Nyb2xsQ29uZmlnLmRlZmF1bHRBZHZhbmNlZElubGluZU9mZnNldENhbGN1bGF0aW9uO1xuICAgICAgICAvKiBFdmVudCBlbWl0dGVyIHRvIG5vdGlmeSB0aGUgd29ybGQgYWJvdXQgdGhlIHNjcm9sbGluZyAqL1xuICAgICAgICB0aGlzLl9wYWdlU2Nyb2xsRmluaXNoID0gbmV3IGNvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVzZSBwcm9wZXJ0aWVzIHdpbGwgYmUgc2V0L21hbmlwdWxhdGVkIGlmIHRoZSBzY3JvbGwgYW5pbWF0aW9uIHN0YXJ0c1xuICAgICAgICAgKi9cbiAgICAgICAgLyogVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0IHBvc2l0aW9uIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHMgKi9cbiAgICAgICAgdGhpcy5fc3RhcnRTY3JvbGxQb3NpdGlvbiA9IDA7XG4gICAgICAgIC8qIFdoZXRoZXIgYW4gaW50ZXJydXB0IGxpc3RlbmVyIGlzIGF0dGFjaGVkIHRvIHRoZSBib2R5IG9yIG5vdCAqL1xuICAgICAgICB0aGlzLl9pbnRlcnJ1cHRMaXN0ZW5lcnNBdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICAvKiBSZWZlcmVuY2VzIHRvIHRoZSB0aW1lciBpbnN0YW5jZSB0aGF0IGlzIHVzZWQgdG8gcGVyZm9ybSB0aGUgc2Nyb2xsIGFuaW1hdGlvbiB0byBiZVxuICAgICAgICAgYWJsZSB0byBjbGVhciBpdCBvbiBhbmltYXRpb24gZW5kKi9cbiAgICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB9XG4gICAgLypcbiAgICAgKiBGYWN0b3J5IG1ldGhvZHMgZm9yIGluc3RhbmNlIGNyZWF0aW9uXG4gICAgICovXG4gICAgUGFnZVNjcm9sbEluc3RhbmNlLnNpbXBsZUluc3RhbmNlID0gZnVuY3Rpb24gKGRvY3VtZW50LCBzY3JvbGxUYXJnZXQsIG5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gUGFnZVNjcm9sbEluc3RhbmNlLm5ld0luc3RhbmNlKHtcbiAgICAgICAgICAgIGRvY3VtZW50OiBkb2N1bWVudCxcbiAgICAgICAgICAgIHNjcm9sbFRhcmdldDogc2Nyb2xsVGFyZ2V0LFxuICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQYWdlU2Nyb2xsSW5zdGFuY2UubmV3SW5zdGFuY2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAoUGFnZVNjcm9sbFV0aWxTZXJ2aWNlLmlzVW5kZWZpbmVkT3JOdWxsKG9wdGlvbnMubmFtZXNwYWNlKSB8fCBvcHRpb25zLm5hbWVzcGFjZS5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgb3B0aW9ucy5uYW1lc3BhY2UgPSBQYWdlU2Nyb2xsQ29uZmlnLl9kZWZhdWx0TmFtZXNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWdlU2Nyb2xsSW5zdGFuY2UgPSBuZXcgUGFnZVNjcm9sbEluc3RhbmNlKG9wdGlvbnMubmFtZXNwYWNlLCBkb2N1bWVudCk7XG4gICAgICAgIGlmIChQYWdlU2Nyb2xsVXRpbFNlcnZpY2UuaXNVbmRlZmluZWRPck51bGwob3B0aW9ucy5zY3JvbGxpbmdWaWV3cykgfHwgb3B0aW9ucy5zY3JvbGxpbmdWaWV3cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5faXNJbmxpbmVTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5fc2Nyb2xsaW5nVmlld3MgPSBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5LCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLl9pc0lubGluZVNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuX3Njcm9sbGluZ1ZpZXdzID0gb3B0aW9ucy5zY3JvbGxpbmdWaWV3cztcbiAgICAgICAgfVxuICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuX3Njcm9sbFRhcmdldCA9IG9wdGlvbnMuc2Nyb2xsVGFyZ2V0O1xuICAgICAgICBpZiAoIVBhZ2VTY3JvbGxVdGlsU2VydmljZS5pc1VuZGVmaW5lZE9yTnVsbChvcHRpb25zLnZlcnRpY2FsU2Nyb2xsaW5nKSkge1xuICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLl92ZXJ0aWNhbFNjcm9sbGluZyA9IG9wdGlvbnMudmVydGljYWxTY3JvbGxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQYWdlU2Nyb2xsVXRpbFNlcnZpY2UuaXNVbmRlZmluZWRPck51bGwob3B0aW9ucy5wYWdlU2Nyb2xsT2Zmc2V0KSkge1xuICAgICAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLl9vZmZzZXQgPSBvcHRpb25zLnBhZ2VTY3JvbGxPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQYWdlU2Nyb2xsVXRpbFNlcnZpY2UuaXNVbmRlZmluZWRPck51bGwob3B0aW9ucy5wYWdlU2Nyb2xsRWFzaW5nTG9naWMpKSB7XG4gICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuX2Vhc2luZ0xvZ2ljID0gb3B0aW9ucy5wYWdlU2Nyb2xsRWFzaW5nTG9naWM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFBhZ2VTY3JvbGxVdGlsU2VydmljZS5pc1VuZGVmaW5lZE9yTnVsbChvcHRpb25zLnBhZ2VTY3JvbGxEdXJhdGlvbikgJiYgIVBhZ2VTY3JvbGxVdGlsU2VydmljZS5pc1VuZGVmaW5lZE9yTnVsbChvcHRpb25zLnBhZ2VTY3JvbGxTcGVlZCkpIHtcbiAgICAgICAgICAgIC8vIE5vIGR1cmF0aW9uIHNwZWNpZmllZCBpbiB0aGUgb3B0aW9ucywgb25seSBpbiB0aGlzIGNhc2Ugd2UgdXNlIHRoZSBzcGVlZCBvcHRpb24gd2hlbiBwcmVzZW50XG4gICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuX3NwZWVkID0gb3B0aW9ucy5wYWdlU2Nyb2xsU3BlZWQ7XG4gICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuX2R1cmF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFQYWdlU2Nyb2xsVXRpbFNlcnZpY2UuaXNVbmRlZmluZWRPck51bGwob3B0aW9ucy5wYWdlU2Nyb2xsRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuX2R1cmF0aW9uID0gb3B0aW9ucy5wYWdlU2Nyb2xsRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQYWdlU2Nyb2xsVXRpbFNlcnZpY2UuaXNVbmRlZmluZWRPck51bGwob3B0aW9ucy5wYWdlU2Nyb2xsRmluaXNoTGlzdGVuZXIpKSB7XG4gICAgICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuX3BhZ2VTY3JvbGxGaW5pc2ggPSBvcHRpb25zLnBhZ2VTY3JvbGxGaW5pc2hMaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuX2ludGVycnVwdGlibGUgPSBvcHRpb25zLnBhZ2VTY3JvbGxJbnRlcnJ1cHRpYmxlIHx8XG4gICAgICAgICAgICAoUGFnZVNjcm9sbFV0aWxTZXJ2aWNlLmlzVW5kZWZpbmVkT3JOdWxsKG9wdGlvbnMucGFnZVNjcm9sbEludGVycnVwdGlibGUpICYmIFBhZ2VTY3JvbGxDb25maWcuZGVmYXVsdEludGVycnVwdGlibGUpO1xuICAgICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuX2FkdmFuY2VkSW5saW5lT2Zmc2V0Q2FsY3VsYXRpb24gPSBvcHRpb25zLmFkdmFuY2VkSW5saW5lT2Zmc2V0Q2FsY3VsYXRpb24gfHxcbiAgICAgICAgICAgIChQYWdlU2Nyb2xsVXRpbFNlcnZpY2UuaXNVbmRlZmluZWRPck51bGwob3B0aW9ucy5hZHZhbmNlZElubGluZU9mZnNldENhbGN1bGF0aW9uKSAmJlxuICAgICAgICAgICAgICAgIFBhZ2VTY3JvbGxDb25maWcuZGVmYXVsdEFkdmFuY2VkSW5saW5lT2Zmc2V0Q2FsY3VsYXRpb24pO1xuICAgICAgICByZXR1cm4gcGFnZVNjcm9sbEluc3RhbmNlO1xuICAgIH07XG4gICAgUGFnZVNjcm9sbEluc3RhbmNlLnByb3RvdHlwZS5nZXRTY3JvbGxQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24gKHNjcm9sbGluZ1ZpZXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZlcnRpY2FsU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Nyb2xsaW5nVmlldy5zY3JvbGxMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY3JvbGxpbmdWaWV3LnNjcm9sbFRvcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgdGhlIGV4YWN0IGxvY2F0aW9uIG9mIHRoZSBzY3JvbGxUYXJnZXQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEV4dHJhY3QgdGhlIHNjcm9sbFRhcmdldCBIVE1MRWxlbWVudCBmcm9tIHRoZSBnaXZlbiBQYWdlU2Nyb2xsVGFyZ2V0IG9iamVjdC4gVGhlIGxhdHRlciBvbmUgbWF5IGJlXG4gICAgICogYSBzdHJpbmcgbGlrZSBcIiNoZWFkaW5nMlwiLCB0aGVuIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgRE9NIGVsZW1lbnQgZm9yIHRoYXQgaWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgUGFnZVNjcm9sbEluc3RhbmNlLnByb3RvdHlwZS5leHRyYWN0U2Nyb2xsVGFyZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JvbGxUYXJnZXRFbGVtZW50O1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3Njcm9sbFRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRTZWxlY3RvciA9IHRoaXMuX3Njcm9sbFRhcmdldDtcbiAgICAgICAgICAgIGlmICh0YXJnZXRTZWxlY3Rvci5tYXRjaCgvXiNbXlxcc10rJC9nKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEl0J3MgYW4gaWQgc2VsZWN0b3IgYW5kIGEgdmFsaWQgaWQsIGFzIGl0IGRvZXMgbm90IGNvbnRhaW4gYW55IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXRFbGVtZW50ID0gdGhpcy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXRTZWxlY3Rvci5zdWJzdHIoMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0RWxlbWVudCA9IHRoaXMuZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXRTZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxUYXJnZXRFbGVtZW50ID0gdGhpcy5fc2Nyb2xsVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXRFbGVtZW50ID09PSBudWxsIHx8IHNjcm9sbFRhcmdldEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2Nyb2xsIHRhcmdldCBub3QgZm91bmRcbiAgICAgICAgICAgIHJldHVybiB7IHRvcDogTmFOLCBsZWZ0OiBOYU4gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNJbmxpbmVTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHsgdG9wOiBzY3JvbGxUYXJnZXRFbGVtZW50Lm9mZnNldFRvcCwgbGVmdDogc2Nyb2xsVGFyZ2V0RWxlbWVudC5vZmZzZXRMZWZ0IH07XG4gICAgICAgICAgICBpZiAodGhpcy5fYWR2YW5jZWRJbmxpbmVPZmZzZXRDYWxjdWxhdGlvbiAmJiB0aGlzLnNjcm9sbGluZ1ZpZXdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZFBhcmVudHNQb3MgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICAgICAgICAgICAgICAgIC8vIG5vdCBuYW1lZCB3aW5kb3cgdG8gbWFrZSBzdXJlIHdlJ3JlIG5vdCBnZXR0aW5nIHRoZSBnbG9iYWwgd2luZG93IHZhcmlhYmxlIGJ5IGFjY2lkZW50XG4gICAgICAgICAgICAgICAgdmFyIHRoZVdpbmRvdyA9IHNjcm9sbFRhcmdldEVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBwYXJlbnQgaXMgdGhlIGltbWVkaWF0ZSBwYXJlbnRcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBzY3JvbGxUYXJnZXRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSB1cHdhcmRzIGFsbCBwYXJlbnRzXG4gICAgICAgICAgICAgICAgd2hpbGUgKCFwYXJlbnRGb3VuZCAmJiAhUGFnZVNjcm9sbFV0aWxTZXJ2aWNlLmlzVW5kZWZpbmVkT3JOdWxsKHBhcmVudF8xKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhlV2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50XzEpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdyZWxhdGl2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFyZW50c1Bvcy50b3AgKz0gcGFyZW50XzEub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRQYXJlbnRzUG9zLmxlZnQgKz0gcGFyZW50XzEub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRfMSA9IHBhcmVudF8xLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEZvdW5kID0gcGFyZW50XzEgPT09IHRoaXMuc2Nyb2xsaW5nVmlld3NbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHVzZSB0aGUgcmVzdWx0cyBpZiB3ZSBmb3VuZCB0aGUgcGFyZW50LCBvdGhlcndpc2Ugd2UgYWNjdW11bGF0ZWQgdG9vIG11Y2ggYW55d2F5XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnRvcCArPSBhY2N1bXVsYXRlZFBhcmVudHNQb3MudG9wO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5sZWZ0ICs9IGFjY3VtdWxhdGVkUGFyZW50c1Bvcy5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBhZ2VTY3JvbGxDb25maWcuX2xvZ0xldmVsID49IDIgfHwgKFBhZ2VTY3JvbGxDb25maWcuX2xvZ0xldmVsID49IDEgJiYgY29yZS5pc0Rldk1vZGUoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGZpbmQgbmVzdGVkIHNjcm9sbGluZyB0YXJnZXRzIHBhcmVudCEnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFnZVNjcm9sbFV0aWxTZXJ2aWNlLmV4dHJhY3RFbGVtZW50UG9zaXRpb24odGhpcy5kb2N1bWVudCwgc2Nyb2xsVGFyZ2V0RWxlbWVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRvcCBvZmZzZXQgb2YgdGhlIHNjcm9sbCBhbmltYXRpb24uXG4gICAgICogVGhpcyBhdXRvbWF0aWNhbGx5IHRha2VzIHRoZSBvZmZzZXQgbG9jYXRpb24gb2YgdGhlIHNjcm9sbGluZyBjb250YWluZXIvc2Nyb2xsaW5nIHZpZXdcbiAgICAgKiBpbnRvIGFjY291bnQgKGZvciBuZXN0ZWQvaW5saW5lIHNjcm9sbGluZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIFBhZ2VTY3JvbGxJbnN0YW5jZS5wcm90b3R5cGUuZ2V0Q3VycmVudE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFwic2Nyb2xsVG9wXCIgb3IgXCJzY3JvbGxMZWZ0XCIgcHJvcGVydHkgZm9yIGFsbCBzY3JvbGxpbmdWaWV3cyB0byB0aGUgcHJvdmlkZWQgdmFsdWVcbiAgICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgYXQgbGVhc3QgZm9yIG9uZSBTY3JvbGxUb3BTb3VyY2UgdGhlIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IHZhbHVlIGNvdWxkIGJlIHNldCBhbmQgaXQga2VwdCB0aGUgbmV3IHZhbHVlLlxuICAgICAqICAgICAgICAgIGZhbHNlIGlmIGl0IGZhaWxlZCBmb3IgYWxsIFNjcm9sbGluZ1ZpZXdzLCBtZWFuaW5nIHRoYXQgd2Ugc2hvdWxkIHN0b3AgdGhlIGFuaW1hdGlvblxuICAgICAqICAgICAgICAgIChwcm9iYWJseSBiZWNhdXNlIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIHNjcm9sbGluZyByZWdpb24pXG4gICAgICovXG4gICAgUGFnZVNjcm9sbEluc3RhbmNlLnByb3RvdHlwZS5zZXRTY3JvbGxQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoUGFnZVNjcm9sbENvbmZpZy5fbG9nTGV2ZWwgPj0gNSAmJiBjb3JlLmlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1Njcm9sbCBQb3NpdGlvbjogJyArIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIG5ldyBzY3JvbGxUb3Avc2Nyb2xsTGVmdCB0byBhbGwgc2Nyb2xsaW5nVmlld3MgZWxlbWVudHNcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsaW5nVmlld3MucmVkdWNlKGZ1bmN0aW9uIChvbmVBbHJlYWR5V29ya2VkLCBzY3JvbGxpbmdWaWV3KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRTY3JvbGxQcm9wZXJ0eVZhbHVlID0gX3RoaXMuZ2V0U2Nyb2xsUHJvcGVydHlWYWx1ZShzY3JvbGxpbmdWaWV3KTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxpbmdWaWV3ICYmICFQYWdlU2Nyb2xsVXRpbFNlcnZpY2UuaXNVbmRlZmluZWRPck51bGwoc3RhcnRTY3JvbGxQcm9wZXJ0eVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxEaXN0YW5jZSA9IE1hdGguYWJzKHN0YXJ0U2Nyb2xsUHJvcGVydHlWYWx1ZSAtIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbW92ZW1lbnQgd2UgbmVlZCB0byBwZXJmb3JtIGlzIGxlc3MgdGhhbiAycHhcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdlIGNvbnNpZGVyIGEgc21hbGwgbW92ZW1lbnQgd2hpY2ggc29tZSBicm93c2VyIG1heSBub3QgcGVyZm9ybSB3aGVuXG4gICAgICAgICAgICAgICAgLy8gY2hhbmdpbmcgdGhlIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gVGh1cyBpbiB0aGlzIGNhc2VzIHdlIGRvIG5vdCBzdG9wIHRoZSBzY3JvbGwgYW5pbWF0aW9uLCBhbHRob3VnaCBzZXR0aW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IHZhbHVlIFwiZmFpbHNcIlxuICAgICAgICAgICAgICAgIHZhciBpc1NtYWxsTW92ZW1lbnQgPSBzY3JvbGxEaXN0YW5jZSA8IFBhZ2VTY3JvbGxDb25maWcuX21pblNjcm9sbERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMudmVydGljYWxTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsaW5nVmlldy5zY3JvbGxMZWZ0ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxpbmdWaWV3LnNjcm9sbFRvcCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdHJ1ZSBvZiBzZXR0aW5nIHRoZSBuZXcgc2Nyb2xsVG9wL3Njcm9sbExlZnQgdmFsdWUgd29ya2VkXG4gICAgICAgICAgICAgICAgLy8gV2UgY29uc2lkZXIgdGhhdCBpdCB3b3JrZWQgaWYgdGhlIG5ldyBzY3JvbGxUb3Avc2Nyb2xsTGVmdCB2YWx1ZSBpcyBjbG9zZXIgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gZGVzaXJlZCBzY3JvbGxUb3Avc2Nyb2xsTGVmdCB0aGFuIGJlZm9yZSAoaXQgbWlnaHQgbm90IGJlIGV4YWN0bHkgdGhlIHZhbHVlIHdlXG4gICAgICAgICAgICAgICAgLy8gc2V0IGR1ZSB0byBkcGkgb3Igcm91bmRpbmcgaXJyZWd1bGFyaXRpZXMpXG4gICAgICAgICAgICAgICAgaWYgKGlzU21hbGxNb3ZlbWVudCB8fCBzY3JvbGxEaXN0YW5jZSA+IE1hdGguYWJzKF90aGlzLmdldFNjcm9sbFByb3BlcnR5VmFsdWUoc2Nyb2xsaW5nVmlldykgLSBwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9uZUFscmVhZHlXb3JrZWQ7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgZmlyaW5nIGEgYW5pbWF0aW9uIGZpbmlzaCBldmVudFxuICAgICAqIEBwYXJhbSB2YWx1ZSBXaGV0aGVyIHRoZSBhbmltYXRpb24gZmluaXNoZWQgYXQgdGhlIHRhcmdldCAodHJ1ZSkgb3IgZ290IGludGVycnVwdGVkIChmYWxzZSlcbiAgICAgKi9cbiAgICBQYWdlU2Nyb2xsSW5zdGFuY2UucHJvdG90eXBlLmZpcmVFdmVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fcGFnZVNjcm9sbEZpbmlzaCkge1xuICAgICAgICAgICAgdGhpcy5fcGFnZVNjcm9sbEZpbmlzaC5lbWl0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoIHRoZSBpbnRlcnJ1cHQgbGlzdGVuZXJzIHRvIHRoZSBQYWdlU2Nyb2xsSW5zdGFuY2UgYm9keS4gVGhlIGdpdmVuIGludGVycnVwdFJlcG9ydGVyXG4gICAgICogd2lsbCBiZSBjYWxsZWQgaWYgYW55IG9mIHRoZSBhdHRhY2hlZCBldmVudHMgaXMgZmlyZWQuXG4gICAgICpcbiAgICAgKiBQb3NzaWJseSBhdHRhY2hlZCBpbnRlcnJ1cHRMaXN0ZW5lcnMgYXJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSBib2R5IGJlZm9yZSB0aGUgbmV3IG9uZSB3aWxsIGJlIGF0dGFjaGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVycnVwdFJlcG9ydGVyXG4gICAgICovXG4gICAgUGFnZVNjcm9sbEluc3RhbmNlLnByb3RvdHlwZS5hdHRhY2hJbnRlcnJ1cHRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoaW50ZXJydXB0UmVwb3J0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2ludGVycnVwdExpc3RlbmVyc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAvLyBEZXRhY2ggcG9zc2libHkgZXhpc3RpbmcgbGlzdGVuZXJzIGZpcnN0XG4gICAgICAgICAgICB0aGlzLmRldGFjaEludGVycnVwdExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVycnVwdExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpbnRlcnJ1cHRSZXBvcnRlci5yZXBvcnQoZXZlbnQsIF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGFnZVNjcm9sbENvbmZpZy5faW50ZXJydXB0RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5kb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLl9pbnRlcnJ1cHRMaXN0ZW5lcik7IH0pO1xuICAgICAgICB0aGlzLl9pbnRlcnJ1cHRMaXN0ZW5lcnNBdHRhY2hlZCA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGJvZHkgYW5kIHN0b3AgbGlzdGVuaW5nIGZvciBldmVudHMgdGhhdCBtaWdodCBiZSB0cmVhdGVkIGFzIFwiYW5pbWF0aW9uXG4gICAgICogaW50ZXJydXB0XCIgZXZlbnRzLlxuICAgICAqL1xuICAgIFBhZ2VTY3JvbGxJbnN0YW5jZS5wcm90b3R5cGUuZGV0YWNoSW50ZXJydXB0TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBQYWdlU2Nyb2xsQ29uZmlnLl9pbnRlcnJ1cHRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuX2ludGVycnVwdExpc3RlbmVyKTsgfSk7XG4gICAgICAgIHRoaXMuX2ludGVycnVwdExpc3RlbmVyc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFnZVNjcm9sbEluc3RhbmNlLnByb3RvdHlwZSwgXCJuYW1lc3BhY2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lc3BhY2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlU2Nyb2xsSW5zdGFuY2UucHJvdG90eXBlLCBcInNjcm9sbFRhcmdldFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbFRhcmdldDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhZ2VTY3JvbGxJbnN0YW5jZS5wcm90b3R5cGUsIFwidmVydGljYWxTY3JvbGxpbmdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZXJ0aWNhbFNjcm9sbGluZztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhZ2VTY3JvbGxJbnN0YW5jZS5wcm90b3R5cGUsIFwic2Nyb2xsaW5nVmlld3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxpbmdWaWV3cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhZ2VTY3JvbGxJbnN0YW5jZS5wcm90b3R5cGUsIFwic3RhcnRTY3JvbGxQb3NpdGlvblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0U2Nyb2xsUG9zaXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFNjcm9sbFBvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlU2Nyb2xsSW5zdGFuY2UucHJvdG90eXBlLCBcInRhcmdldFNjcm9sbFBvc2l0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0U2Nyb2xsUG9zaXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRTY3JvbGxQb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFnZVNjcm9sbEluc3RhbmNlLnByb3RvdHlwZSwgXCJkaXN0YW5jZVRvU2Nyb2xsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb1Njcm9sbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlVG9TY3JvbGwgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhZ2VTY3JvbGxJbnN0YW5jZS5wcm90b3R5cGUsIFwiZXhlY3V0aW9uRHVyYXRpb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leGVjdXRpb25EdXJhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGlvbkR1cmF0aW9uID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlU2Nyb2xsSW5zdGFuY2UucHJvdG90eXBlLCBcImR1cmF0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZHVyYXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlU2Nyb2xsSW5zdGFuY2UucHJvdG90eXBlLCBcInNwZWVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3BlZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlU2Nyb2xsSW5zdGFuY2UucHJvdG90eXBlLCBcImVhc2luZ0xvZ2ljXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZWFzaW5nTG9naWM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlU2Nyb2xsSW5zdGFuY2UucHJvdG90eXBlLCBcImludGVycnVwdGlibGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcnJ1cHRpYmxlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFnZVNjcm9sbEluc3RhbmNlLnByb3RvdHlwZSwgXCJzdGFydFRpbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydFRpbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhZ2VTY3JvbGxJbnN0YW5jZS5wcm90b3R5cGUsIFwiZW5kVGltZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuZFRpbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmRUaW1lID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlU2Nyb2xsSW5zdGFuY2UucHJvdG90eXBlLCBcInRpbWVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFnZVNjcm9sbEluc3RhbmNlLnByb3RvdHlwZSwgXCJpbnRlcnJ1cHRMaXN0ZW5lcnNBdHRhY2hlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVycnVwdExpc3RlbmVyc0F0dGFjaGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gUGFnZVNjcm9sbEluc3RhbmNlO1xufSgpKTtcblxudmFyIFBhZ2VTY3JvbGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhZ2VTY3JvbGwocGFnZVNjcm9sbFNlcnZpY2UsIHJvdXRlciQkMSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5wYWdlU2Nyb2xsU2VydmljZSA9IHBhZ2VTY3JvbGxTZXJ2aWNlO1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlciQkMTtcbiAgICAgICAgdGhpcy5wYWdlU2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYWdlU2Nyb2xsSG9yaXpvbnRhbCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFnZVNjcm9sbE9mZnNldCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFnZVNjcm9sbER1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYWdlU2Nyb2xsU3BlZWQgPSBudWxsO1xuICAgICAgICB0aGlzLnBhZ2VTY3JvbGxFYXNpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLnBhZ2VTY3JvbGxBZGp1c3RIYXNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFnZVNjcm9sbCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFnZVNjcm9sbEZpbmlzaCA9IG5ldyBjb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIFBhZ2VTY3JvbGwucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgLy8gU29tZSBpbnB1dHMgY2hhbmdlZCwgcmVzZXQgdGhlIHBhZ2VTY3JvbGxJbnN0YW5jZVxuICAgICAgICB0aGlzLnBhZ2VTY3JvbGxJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFBhZ2VTY3JvbGwucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYWdlU2Nyb2xsSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMucGFnZVNjcm9sbFNlcnZpY2Uuc3RvcCh0aGlzLnBhZ2VTY3JvbGxJbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFBhZ2VTY3JvbGwucHJvdG90eXBlLmdlbmVyYXRlUGFnZVNjcm9sbEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoUGFnZVNjcm9sbFV0aWxTZXJ2aWNlLmlzVW5kZWZpbmVkT3JOdWxsKHRoaXMucGFnZVNjcm9sbEluc3RhbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5wYWdlU2Nyb2xsSW5zdGFuY2UgPSBQYWdlU2Nyb2xsSW5zdGFuY2UubmV3SW5zdGFuY2Uoe1xuICAgICAgICAgICAgICAgIGRvY3VtZW50OiB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldDogdGhpcy5wYWdlU2Nyb2xsVGFyZ2V0IHx8IHRoaXMuaHJlZixcbiAgICAgICAgICAgICAgICBzY3JvbGxpbmdWaWV3czogbnVsbCxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IHRoaXMucGFnZVNjcm9sbCxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbFNjcm9sbGluZzogIXRoaXMucGFnZVNjcm9sbEhvcml6b250YWwsXG4gICAgICAgICAgICAgICAgcGFnZVNjcm9sbE9mZnNldDogdGhpcy5wYWdlU2Nyb2xsT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHBhZ2VTY3JvbGxJbnRlcnJ1cHRpYmxlOiB0aGlzLnBhZ2VTY3JvbGxJbnRlcnJ1cHRpYmxlLFxuICAgICAgICAgICAgICAgIHBhZ2VTY3JvbGxFYXNpbmdMb2dpYzogdGhpcy5wYWdlU2Nyb2xsRWFzaW5nLFxuICAgICAgICAgICAgICAgIHBhZ2VTY3JvbGxEdXJhdGlvbjogdGhpcy5wYWdlU2Nyb2xsRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgcGFnZVNjcm9sbFNwZWVkOiB0aGlzLnBhZ2VTY3JvbGxTcGVlZCxcbiAgICAgICAgICAgICAgICBwYWdlU2Nyb2xsRmluaXNoTGlzdGVuZXI6IHRoaXMucGFnZVNjcm9sbEZpbmlzaFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZVNjcm9sbEluc3RhbmNlO1xuICAgIH07XG4gICAgUGFnZVNjcm9sbC5wcm90b3R5cGUucHVzaFJvdXRlclN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYWdlU2Nyb2xsQWRqdXN0SGFzaCAmJiB0eXBlb2YgdGhpcy5wYWdlU2Nyb2xsSW5zdGFuY2Uuc2Nyb2xsVGFyZ2V0ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgJiYgdGhpcy5wYWdlU2Nyb2xsSW5zdGFuY2Uuc2Nyb2xsVGFyZ2V0LnN1YnN0cigwLCAxKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAvLyBcIk5hdmlnYXRlXCIgdG8gdGhlIGN1cnJlbnQgcm91dGUgYWdhaW4gYW5kIHRoaXMgdGltZSBzZXQgdGhlIGZyYWdtZW50L2hhc2hcbiAgICAgICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFtdLCB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQ6IHRoaXMucGFnZVNjcm9sbEluc3RhbmNlLnNjcm9sbFRhcmdldC5zdWJzdHIoMSksXG4gICAgICAgICAgICAgICAgcHJlc2VydmVRdWVyeVBhcmFtczogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhZ2VTY3JvbGwucHJvdG90eXBlLnNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhZ2VTY3JvbGxJbnN0YW5jZSA9IHRoaXMuZ2VuZXJhdGVQYWdlU2Nyb2xsSW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5wdXNoUm91dGVyU3RhdGUoKTtcbiAgICAgICAgdGhpcy5wYWdlU2Nyb2xsU2VydmljZS5zdGFydChwYWdlU2Nyb2xsSW5zdGFuY2UpO1xuICAgIH07XG4gICAgUGFnZVNjcm9sbC5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoY2xpY2tFdmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5yb3V0ZXJMaW5rICYmIHRoaXMucm91dGVyICE9PSBudWxsICYmIHRoaXMucm91dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciB1cmxUcmVlID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJvdXRlckxpbmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdXJsVHJlZSA9IHRoaXMucm91dGVyLnBhcnNlVXJsKHRoaXMucm91dGVyTGluayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmxUcmVlID0gdGhpcy5yb3V0ZXIuY3JlYXRlVXJsVHJlZSh0aGlzLnJvdXRlckxpbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJvdXRlci5pc0FjdGl2ZSh1cmxUcmVlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbmF2aWdhdGUgdGhlaXIgZmlyc3QuXG4gICAgICAgICAgICAgICAgLy8gTmF2aWdhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSByb3V0ZXJMaW5rIGRpcmVjdGl2ZVxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIG9ubHkgbmVlZCB0byBsaXN0ZW4gZm9yIHJvdXRlIGNoYW5nZVxuICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb25fMSA9IHRoaXMucm91dGVyLmV2ZW50cy5zdWJzY3JpYmUoZnVuY3Rpb24gKHJvdXRlckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZXJFdmVudCBpbnN0YW5jZW9mIHJvdXRlci5OYXZpZ2F0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25fMS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGEgdGltZW91dCB0byBzdGFydCBzY3JvbGxpbmcgYXMgc29vbiBhcyB0aGUgc3RhY2sgaXMgY2xlYXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyb3V0ZXJFdmVudCBpbnN0YW5jZW9mIHJvdXRlci5OYXZpZ2F0aW9uRXJyb3IgfHwgcm91dGVyRXZlbnQgaW5zdGFuY2VvZiByb3V0ZXIuTmF2aWdhdGlvbkNhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uXzEudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gdG8gcHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gdG8gcHJldmVudERlZmF1bHQoKVxuICAgIH07XG4gICAgUGFnZVNjcm9sbC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1twYWdlU2Nyb2xsXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ2hhbmRsZUNsaWNrKCRldmVudCknLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBQYWdlU2Nyb2xsLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IFBhZ2VTY3JvbGxTZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IHJvdXRlci5Sb3V0ZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IGNvcmUuT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlLkluamVjdCwgYXJnczogW2NvbW1vbi5ET0NVTUVOVCxdIH0sXSB9LFxuICAgIF07IH07XG4gICAgUGFnZVNjcm9sbC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ3JvdXRlckxpbmsnOiBbeyB0eXBlOiBjb3JlLklucHV0IH0sXSxcbiAgICAgICAgJ2hyZWYnOiBbeyB0eXBlOiBjb3JlLklucHV0IH0sXSxcbiAgICAgICAgJ3BhZ2VTY3JvbGxUYXJnZXQnOiBbeyB0eXBlOiBjb3JlLklucHV0IH0sXSxcbiAgICAgICAgJ3BhZ2VTY3JvbGxIb3Jpem9udGFsJzogW3sgdHlwZTogY29yZS5JbnB1dCB9LF0sXG4gICAgICAgICdwYWdlU2Nyb2xsT2Zmc2V0JzogW3sgdHlwZTogY29yZS5JbnB1dCB9LF0sXG4gICAgICAgICdwYWdlU2Nyb2xsRHVyYXRpb24nOiBbeyB0eXBlOiBjb3JlLklucHV0IH0sXSxcbiAgICAgICAgJ3BhZ2VTY3JvbGxTcGVlZCc6IFt7IHR5cGU6IGNvcmUuSW5wdXQgfSxdLFxuICAgICAgICAncGFnZVNjcm9sbEVhc2luZyc6IFt7IHR5cGU6IGNvcmUuSW5wdXQgfSxdLFxuICAgICAgICAncGFnZVNjcm9sbEludGVycnVwdGlibGUnOiBbeyB0eXBlOiBjb3JlLklucHV0IH0sXSxcbiAgICAgICAgJ3BhZ2VTY3JvbGxBZGp1c3RIYXNoJzogW3sgdHlwZTogY29yZS5JbnB1dCB9LF0sXG4gICAgICAgICdwYWdlU2Nyb2xsJzogW3sgdHlwZTogY29yZS5JbnB1dCB9LF0sXG4gICAgICAgICdwYWdlU2Nyb2xsRmluaXNoJzogW3sgdHlwZTogY29yZS5PdXRwdXQgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIFBhZ2VTY3JvbGw7XG59KCkpO1xuXG52YXIgTmcyUGFnZVNjcm9sbE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmcyUGFnZVNjcm9sbE1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIHNpbmNlIHY0LjAuMC1iZXRhLjEwIChodHRwczovL2dpdGh1Yi5jb20vTm9sYW51cy9uZzItcGFnZS1zY3JvbGwvcHVsbC8xOTApICovXG4gICAgTmcyUGFnZVNjcm9sbE1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5nMlBhZ2VTY3JvbGxNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IFBhZ2VTY3JvbGxTZXJ2aWNlLCB1c2VDbGFzczogUGFnZVNjcm9sbFNlcnZpY2UgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTmcyUGFnZVNjcm9sbE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtjb21tb24uQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbUGFnZVNjcm9sbF0sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtQYWdlU2Nyb2xsXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTkcyUEFHRVNDUk9MTF9TRVJWSUNFX1BST1ZJREVSXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgTmcyUGFnZVNjcm9sbE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBOZzJQYWdlU2Nyb2xsTW9kdWxlO1xufSgpKTtcblxuZXhwb3J0cy5QYWdlU2Nyb2xsID0gUGFnZVNjcm9sbDtcbmV4cG9ydHMuUGFnZVNjcm9sbFNlcnZpY2UgPSBQYWdlU2Nyb2xsU2VydmljZTtcbmV4cG9ydHMuTkcyUEFHRVNDUk9MTF9TRVJWSUNFX1BST1ZJREVSX0ZBQ1RPUlkgPSBORzJQQUdFU0NST0xMX1NFUlZJQ0VfUFJPVklERVJfRkFDVE9SWTtcbmV4cG9ydHMuTkcyUEFHRVNDUk9MTF9TRVJWSUNFX1BST1ZJREVSID0gTkcyUEFHRVNDUk9MTF9TRVJWSUNFX1BST1ZJREVSO1xuZXhwb3J0cy5FYXNpbmdMb2dpYyA9IEVhc2luZ0xvZ2ljO1xuZXhwb3J0cy5QYWdlU2Nyb2xsQ29uZmlnID0gUGFnZVNjcm9sbENvbmZpZztcbmV4cG9ydHMuUGFnZVNjcm9sbEluc3RhbmNlID0gUGFnZVNjcm9sbEluc3RhbmNlO1xuZXhwb3J0cy5QYWdlU2Nyb2xsVXRpbFNlcnZpY2UgPSBQYWdlU2Nyb2xsVXRpbFNlcnZpY2U7XG5leHBvcnRzLk5nMlBhZ2VTY3JvbGxNb2R1bGUgPSBOZzJQYWdlU2Nyb2xsTW9kdWxlO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl19